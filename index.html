<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrakis Tycoon - Dune MMO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #1c1917; /* Darker Stone */ }
        h1, h2, h3, h4, .font-orbitron { font-family: 'Orbitron', sans-serif; }
        .tab-button { transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-bottom-color 0.2s ease-in-out; }
        .tab-button.active { border-bottom-color: #f59e0b; /* Amber-500 */ color: #f59e0b; }
        .progress-bar-bg { background-color: #57534e; /* Stone-600 */ }
        .progress-bar-fill { background-color: #f59e0b; /* Amber-500 */ transition: width 0.3s ease; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #44403c; /* Stone-700 */ border-radius: 4px;}
        ::-webkit-scrollbar-thumb { background: #a8a29e; /* Stone-400 */ border-radius: 4px;}
        ::-webkit-scrollbar-thumb:hover { background: #d6d3d1; /* Stone-300 */ }
        .map-grid { display: grid; gap: 1px; background-color: #292524; /* Stone-800 */ border: 1px solid #44403c; }
        .map-cell { width: 2rem; height: 2rem; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: bold; border-radius: 0.125rem; cursor: pointer; transition: background-color 0.1s; }
        /* Add a class for the map container to make it scrollable if map is too big */
        .map-scroll-container { max-width: 100%; overflow-x: auto; }
    </style>
</head>
<body class="bg-stone-900 text-amber-50 antialiased">

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, addDoc, getDocs, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Firebase Variables ---
        let db, auth, userId, app;
        let isAuthReady = false;
        let unsubscribePlayerListener = null;
        let unsubscribePlayersListener = null;
        let unsubscribeChatListener = null;
        let unsubscribeGuildListener = null;
        let unsubscribeWorldEventsListener = null;
        let unsubscribeMapResourcesListener = null;

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'arrakis-tycoon-default'; // Default for local testing

        // --- Game Data Structure ---
        let gameData = {
            character: {
                house: null,
                background: null,
                name: "Survivor",
                health: 100,
                maxHealth: 100,
                attack: 10,
                defense: 5,
                level: 1,
                experience: 0,
                experienceToNextLevel: 100,
                position: { x: 10, y: 10 },
                equipment: { weapon: null, armor: null, accessory: null },
                guildId: null,
                isOnline: false,
                lastSeen: null,
                pvpEnabled: false,
            },
            resources: {
                spice: 0,
                water: 50,
                solari: 200,
                plasteel: 0,
                food: 20
            },
            harvesters: {
                spice_harvester_manual_level: 1,
                spice_harvester_auto_level: 0,
                spice_harvester_auto_count: 0,
                water_collector_auto_level: 0,
                water_collector_auto_count: 0,
            },
            upgrades: {
                spice_auto_cost: 100,
                water_auto_cost: 150,
                spice_manual_upgrade_cost: 20,
            },
            inventory: [],
            craftingRecipes: [
                { id: 'basic_stillsuit_patch', name: 'Stillsuit Patch', cost: { water: 5, plasteel: 2 }, output: { id: 'stillsuit_patch_item', name: 'Stillsuit Patch', quantity: 1, type: 'consumable', effect: { health: 10 }}, description: "A basic patch for your stillsuit. Restores a bit of health by preventing dehydration."},
                { id: 'purified_water', name: 'Purified Water', cost: { water: 10 }, output: { id: 'purified_water_item', name: 'Purified Water', quantity: 1, type: 'consumable', effect: { health: 25 }}, description: "Critical for survival. Restores health."},
                { id: 'desert_ration', name: 'Desert Ration', cost: { water: 5, spice: 2 }, output: { id: 'desert_ration_item', name: 'Desert Ration', quantity: 1, type: 'consumable', effect: { food: 15 }}, description: "Compressed nutrients for desert travel."},
                { id: 'crysknife', name: 'Crysknife', cost: { plasteel: 15, spice: 30 }, output: { id: 'crysknife_item', name: 'Crysknife', quantity: 1, type: 'weapon', stats: { attack: 15 }}, description: "Sacred Fremen weapon made from a sandworm tooth."}
            ],
            buildings: [],
            units: [],
            players: {}, 
            chatMessages: [], 
            guilds: {}, 
            activeWorldEvents: {}, 
            map: { 
                width: 50, 
                height: 50, 
                visibleRadius: 3,
                explored: {}, 
                locations: [
                    { x: 5, y: 5, type: 'settlement', name: 'Sietch Tabr', description: 'A hidden Fremen community', friendly: true },
                    { x: 40, y: 40, type: 'settlement', name: 'Arrakeen', description: 'The planetary capital, a hub of activity.', friendly: true, market: true },
                    { x: 15, y: 35, type: 'ruins', name: 'Ancient Outpost', description: 'Ruins of an old outpost, rumored to hold secrets.', loot: true },
                    { x: 25, y: 10, type: 'oasis', name: 'Hidden Spring', description: 'A rare water source in the desert', resource: 'water' },
                    { x: 30, y: 25, type: 'harkonnen_outpost', name: 'Harkonnen Patrol Point', description: 'A heavily guarded Harkonnen outpost.', enemyPresence: true}
                ],
                map_enemies: [], 
                map_features: {}, 
                map_resources: []  
            },
            quests: [],
            combat: { 
                inCombat: false,
                enemy: null,
                playerTurn: true,
                turnTimer: 0,
                maxTurnTime: 15, 
                messages: []
            },
            settings: { 
                gameSpeed: 1000,
                soundEnabled: true,
                difficultyLevel: 'normal'
            },
            stats: { 
                totalSpiceHarvested: 0,
                totalSolariEarned: 0,
                enemiesDefeated: 0,
                areasExplored: 0,
                questsCompleted: 0
            },
            lastUpdated: null, 
            gameInitialized: false,
            currentTab: 'game',
            isLoading: true, 
        };

        // --- Static Game Definitions (moved from gameData for clarity) ---
        const STATIC_BUILDINGS = [
            { id: 'spice_refinery', name: 'Spice Refinery', cost: { solari: 500, plasteel: 20 }, maxLevel: 5, production: { spice: 5 }, upgradeCostFactor: 1.5, description: "Refines raw spice into higher quality product." },
            { id: 'water_still', name: 'Water Still', cost: { solari: 300, plasteel: 15 }, maxLevel: 5, production: { water: 3 }, upgradeCostFactor: 1.6, description: "Extracts water from the air." },
            { id: 'barracks', name: 'Barracks', cost: { solari: 400, plasteel: 25 }, maxLevel: 3, unitCapacity: 5, upgradeCostFactor: 1.7, description: "Trains and houses your fighters." },
            { id: 'research_lab', name: 'Research Lab', cost: { solari: 1000, plasteel: 50}, maxLevel: 3, description: "Unlocks advanced technologies and upgrades.", unlocks: ['advanced_stillsuit', 'spice_compression'] }
        ];
        const STATIC_UNITS = [
            { id: 'fighter', name: 'Fremen Warrior', cost: { solari: 100, food: 5, water: 2 }, stats: { attack: 8, defense: 5 }, upkeep: { food: 1, water: 0.5 }, description: "Basic Fremen combat unit, skilled in desert warfare." },
            { id: 'spice_harvester_unit', name: 'Spice Harvester Crew', cost: { solari: 250, food: 10 }, stats: { spiceGatherRate: 5 }, upkeep: { food: 2, water: 1 }, description: "Automated crew for deploying to spice fields." },
            { id: 'scout_unit', name: 'Desert Scout', cost: {solari: 80, food: 3, water: 3}, stats: { visionRange: 1, speed: 2}, upkeep: {food: 0.5, water: 0.5}, description: "Fast unit for exploration and reconnaissance."}
        ];
        const STATIC_QUESTS = [
            {
                id: 'q1', title: 'First Steps on Arrakis', description: 'Survive your first day on the desert planet by gathering resources.',
                objectives: [ { id: 'q1_o1', description: 'Harvest 50 Spice', target: 'resource', resourceType: 'spice', amount: 50 }, { id: 'q1_o2', description: 'Craft a Stillsuit Patch', target: 'craft', itemId: 'basic_stillsuit_patch', amount: 1 }],
                rewards: { solari: 100, experience: 50 }, active: true 
            },
            {
                id: 'q2', title: 'Exploration Begins', description: 'Venture into the desert and discover what lies beyond.',
                objectives: [ { id: 'q2_o1', description: 'Explore 10 new areas', target: 'explore', amount: 10 }, { id: 'q2_o2', description: 'Visit Arrakeen', target: 'visit_location', locationName: 'Arrakeen', amount: 1 }],
                rewards: { solari: 200, experience: 100, item: { id: 'desert_boots', name: 'Desert Boots', type: 'accessory', stats: { defense: 5 } } }, active: false
            },
            {
                id: 'q3', title: 'The Spice Trade', description: 'Establish your presence in the spice market.',
                objectives: [ { id: 'q3_o1', description: 'Build a Spice Refinery', target: 'build', buildingId: 'spice_refinery', amount: 1}, { id: 'q3_o2', description: 'Accumulate 500 Solari', target: 'resource', resourceType: 'solari', amount: 500}],
                rewards: { solari: 300, experience: 150, plasteel: 10}, active: false
            }
        ];
        const ENEMY_TYPES = [
            { id: 'harkonnen_scout', name: 'Harkonnen Scout', health: 40, attack: 12, defense: 4, loot: { solari: [15, 30], chance: { spice: 0.5, water: 0.2, plasteel: 0.1 } } },
            { id: 'desert_bandit', name: 'Desert Bandit', health: 35, attack: 15, defense: 3, loot: { solari: [20, 40], chance: { plasteel: 0.4, water: 0.5, food: 0.3 } } },
            { id: 'sand_creature', name: 'Giant Sand Scorpion', health: 70, attack: 18, defense: 10, loot: { spice: [25, 50], chance: { 'sandworm_tooth_fragment': 0.2, plasteel: 0.3 } } },
            { id: 'harkonnen_trooper', name: 'Harkonnen Trooper', health: 60, attack: 16, defense: 8, loot: { solari: [30, 60], chance: { plasteel: 0.5, 'weapon_parts': 0.2 } } }
        ];

        // --- Firestore Initialization and Auth ---
        async function initializeFirebase() {
            try {
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                if (!firebaseConfig.apiKey) { 
                    console.error("Firebase config is missing or incomplete. Multiplayer will be disabled.");
                    addLog("Firebase config missing. Multiplayer disabled.", "error");
                    gameData.isLoading = false;
                    showCharacterCreator(); 
                    return;
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                // setLogLevel('debug'); 

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("User is signed in with UID:", userId);
                        const userIdDisplayEl = document.getElementById('userIdDisplay');
                        if (userIdDisplayEl) userIdDisplayEl.textContent = userId;

                        await loadPlayerData(); 

                        if (gameData.gameInitialized) { // Existing player, data loaded
                            // Update online status for existing player
                            await updatePlayerDocument({
                                "character.isOnline": true,
                                "character.lastSeen": serverTimestamp()
                            });
                            initializeListeners(); 
                        }
                        // For new players (gameData.gameInitialized is false),
                        // isOnline/lastSeen are set in createNewPlayerDocument,
                        // and listeners are initialized in finalizeCharacterCreation.

                    } else {
                        console.log("User is signed out or auth token invalid.");
                        const userIdDisplayEl = document.getElementById('userIdDisplay');
                        if (userIdDisplayEl) userIdDisplayEl.textContent = "Not Connected";
                        
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            try {
                                await signInWithCustomToken(auth, __initial_auth_token);
                                console.log("Signed in with custom token.");
                            } catch (error) {
                                console.error("Error signing in with custom token:", error);
                                await signInAnonymously(auth);
                                console.log("Signed in anonymously after custom token failure.");
                            }
                        } else {
                            await signInAnonymously(auth);
                            console.log("Signed in anonymously.");
                        }
                    }
                    isAuthReady = true;
                });

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                addLog("Error initializing Firebase. Multiplayer disabled.", "error");
                gameData.isLoading = false;
                showCharacterCreator(); 
            }
        }
        window.addEventListener('beforeunload', async () => {
            if (userId && db && gameData.character && gameData.gameInitialized) { 
                const playerDocRef = doc(db, 'artifacts', appId, 'public', 'players', userId);
                try {
                    await updateDoc(playerDocRef, { 
                        "character.isOnline": false, 
                        "character.lastSeen": serverTimestamp() 
                    });
                    console.log("Player status set to offline.");
                } catch (error) {
                    console.error("Error updating player status to offline:", error);
                }
            }
        });


        // --- Player Data Management (Firestore) ---
        async function loadPlayerData() {
            if (!userId || !db) {
                console.error("User ID or DB not available for loading player data.");
                gameData.isLoading = false;
                showCharacterCreator(); 
                return;
            }
            const playerDocRef = doc(db, 'artifacts', appId, 'public', 'players', userId);
            try {
                const docSnap = await getDoc(playerDocRef);
                if (docSnap.exists()) {
                    const playerData = docSnap.data();
                    Object.assign(gameData.character, playerData.character);
                    Object.assign(gameData.resources, playerData.resources);
                    gameData.harvesters = playerData.harvesters || gameData.harvesters;
                    gameData.inventory = playerData.inventory || [];
                    gameData.map.explored = playerData.map_explored || {};
                    gameData.stats = playerData.stats || gameData.stats;
                    gameData.buildings = playerData.buildings || [];
                    gameData.units = playerData.units || [];
                    gameData.quests = playerData.quests || initializePlayerQuests(); 

                    console.log("Player data loaded from Firestore.");
                    addLog("Game data loaded from the sands...", "info");
                    gameData.gameInitialized = true; // Mark as initialized for existing player
                    document.getElementById('characterCreatorScreen').classList.add('hidden');
                    document.getElementById('mainGameScreen').classList.remove('hidden');
                    switchTab('game');

                } else {
                    console.log("No existing player data found. Showing character creator.");
                    addLog("Welcome, new survivor! Create your legend.", "event");
                    gameData.gameInitialized = false; // Explicitly false for new player flow
                    showCharacterCreator(); 
                }
            } catch (error) {
                console.error("Error loading player data:", error);
                addLog("Error loading your data. Please try again.", "error");
                gameData.gameInitialized = false;
                showCharacterCreator(); 
            } finally {
                gameData.isLoading = false;
                updateUI(); 
                generateMapView();
                if (gameData.gameInitialized) { // Only start game loop if actually initialized
                    startGameLoop();
                }
            }
        }

        function initializePlayerQuests() {
            return STATIC_QUESTS.map(q => ({
                questId: q.id,
                completed: false,
                active: q.active || false,
                objectives: q.objectives.reduce((acc, obj) => {
                    acc[obj.id] = { completed: false, progress: 0 };
                    return acc;
                }, {})
            }));
        }


        async function createNewPlayerDocument(characterDetails) {
            if (!userId || !db) {
                 console.error("User ID or DB not available for creating player document.");
                 addLog("Error saving character. Cannot connect to server.", "error");
                 return false;
            }
            const playerDocRef = doc(db, 'artifacts', appId, 'public', 'players', userId);
            // characterDetails already includes isOnline and lastSeen from finalizeCharacterCreation
            const initialPlayerData = {
                character: characterDetails, 
                resources: { ...gameData.resources }, 
                harvesters: { ...gameData.harvesters },
                inventory: [...gameData.inventory],
                map_explored: { ...gameData.map.explored },
                stats: { ...gameData.stats },
                buildings: [],
                units: [],
                quests: initializePlayerQuests(),
                createdAt: serverTimestamp(),
                lastUpdated: serverTimestamp(),
                appId: appId 
            };

            try {
                await setDoc(playerDocRef, initialPlayerData);
                console.log("New player document created in Firestore.");
                Object.assign(gameData.character, initialPlayerData.character);
                Object.assign(gameData.resources, initialPlayerData.resources);
                gameData.harvesters = initialPlayerData.harvesters;
                gameData.inventory = initialPlayerData.inventory;
                gameData.map.explored = initialPlayerData.map_explored;
                gameData.stats = initialPlayerData.stats;
                gameData.buildings = initialPlayerData.buildings;
                gameData.units = initialPlayerData.units;
                gameData.quests = initialPlayerData.quests;

                return true;
            } catch (error) {
                console.error("Error creating new player document:", error);
                addLog("Critical error creating your character. Please refresh.", "error");
                return false;
            }
        }

        async function updatePlayerDocument(dataToUpdate) {
            if (!userId || !db || !isAuthReady) {
                return;
            }
            if (Object.keys(dataToUpdate).length === 0) return; 

            const playerDocRef = doc(db, 'artifacts', appId, 'public', 'players', userId);
            try {
                const updatePayload = { ...dataToUpdate, lastUpdated: serverTimestamp() };
                await updateDoc(playerDocRef, updatePayload);
            } catch (error) {
                console.error("Error updating player document:", error);
            }
        }


        let saveDataTimeout;
        function debouncedSaveGameData() {
            if (!gameData.gameInitialized || gameData.isLoading) return;
            clearTimeout(saveDataTimeout);
            saveDataTimeout = setTimeout(() => {
                // Ensure character object includes current online status for the comprehensive save
                const currentCharacterState = {
                    ...gameData.character,
                    isOnline: true, // Assume active if saving
                    lastSeen: serverTimestamp() // Update last seen on save
                };
                const dataToSave = {
                    character: currentCharacterState,
                    resources: gameData.resources,
                    harvesters: gameData.harvesters,
                    inventory: gameData.inventory,
                    map_explored: gameData.map.explored,
                    stats: gameData.stats,
                    buildings: gameData.buildings,
                    units: gameData.units,
                    quests: gameData.quests,
                };
                updatePlayerDocument(dataToSave); 
                addLog("Progress saved to the cloud.", "info");
            }, 5000); 
        }


        // --- Firestore Listeners ---
        function initializeListeners() {
            if (!userId || !db) return;

            const playerDocRef = doc(db, 'artifacts', appId, 'public', 'players', userId);
            if (unsubscribePlayerListener) unsubscribePlayerListener();
            unsubscribePlayerListener = onSnapshot(playerDocRef, (docSnap) => {
                if (docSnap.exists() && gameData.gameInitialized) { 
                }
            }, error => console.error("Player listener error:", error));

            const playersColRef = collection(db, 'artifacts', appId, 'public', 'players');
            const qPlayers = query(playersColRef, where("character.isOnline", "==", true), where("appId", "==", appId));
            if (unsubscribePlayersListener) unsubscribePlayersListener();
            unsubscribePlayersListener = onSnapshot(qPlayers, (snapshot) => {
                const newPlayersData = {};
                snapshot.forEach((doc) => {
                    if (doc.id !== userId) { 
                        newPlayersData[doc.id] = { id: doc.id, ...doc.data().character }; 
                    }
                });
                gameData.players = newPlayersData;
                if (gameData.currentTab === 'map' || gameData.currentTab === 'multiplayer') {
                    generateMapView();
                    updatePlayerTracker();
                }
            }, error => console.error("Other players listener error:", error));

            const chatColRef = collection(db, 'artifacts', appId, 'public', 'chat');
            const qChat = query(chatColRef, where("appId", "==", appId), where("timestamp", ">", new Date(Date.now() - 3 * 60 * 60 * 1000))); 
            if (unsubscribeChatListener) unsubscribeChatListener();
            unsubscribeChatListener = onSnapshot(qChat, (snapshot) => {
                const messages = [];
                snapshot.forEach((doc) => {
                    messages.push({ id: doc.id, ...doc.data() });
                });
                gameData.chatMessages = messages.sort((a, b) => (a.timestamp?.toDate() || 0) - (b.timestamp?.toDate() || 0) );
                if (gameData.currentTab === 'multiplayer') updateChatDisplay();
            }, error => console.error("Chat listener error:", error));

            if (gameData.character.guildId) {
                const guildDocRef = doc(db, 'artifacts', appId, 'public', 'guilds', gameData.character.guildId);
                if (unsubscribeGuildListener) unsubscribeGuildListener();
                unsubscribeGuildListener = onSnapshot(guildDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        gameData.guilds[docSnap.id] = { id: docSnap.id, ...docSnap.data() };
                        if (gameData.currentTab === 'multiplayer') updateGuildDisplay();
                    }
                }, error => console.error("Guild listener error:", error));
            }

            const worldEventsColRef = collection(db, 'artifacts', appId, 'public', 'worldEvents');
            const qWorldEvents = query(worldEventsColRef, where("appId", "==", appId));
            if (unsubscribeWorldEventsListener) unsubscribeWorldEventsListener();
            unsubscribeWorldEventsListener = onSnapshot(qWorldEvents, (snapshot) => {
                const activeEvents = {};
                snapshot.forEach((doc) => {
                    const eventData = doc.data();
                    if (!eventData.endTime || eventData.endTime.toDate() > new Date()) {
                         activeEvents[doc.id] = { id: doc.id, ...eventData };
                    }
                });
                gameData.activeWorldEvents = activeEvents;
                if (gameData.currentTab === 'multiplayer') updateWorldEventsDisplay();
            }, error => console.error("World events listener error:", error));

            const mapResourcesColRef = collection(db, 'artifacts', appId, 'public', 'mapResources');
            const qMapResources = query(mapResourcesColRef, where("appId", "==", appId));
            if (unsubscribeMapResourcesListener) unsubscribeMapResourcesListener();
            unsubscribeMapResourcesListener = onSnapshot(qMapResources, (snapshot) => {
                const resources = [];
                snapshot.forEach((doc) => {
                    resources.push({ id: doc.id, ...doc.data() });
                });
                gameData.map.map_resources = resources;
                if (gameData.currentTab === 'map') generateMapView();
            }, error => console.error("Map resources listener error:", error));
            
            console.log("All Firestore listeners initialized.");
        }

        function cleanupListeners() {
            if (unsubscribePlayerListener) unsubscribePlayerListener();
            if (unsubscribePlayersListener) unsubscribePlayersListener();
            if (unsubscribeChatListener) unsubscribeChatListener();
            if (unsubscribeGuildListener) unsubscribeGuildListener();
            if (unsubscribeWorldEventsListener) unsubscribeWorldEventsListener();
            if (unsubscribeMapResourcesListener) unsubscribeMapResourcesListener();
            console.log("Firestore listeners cleaned up.");
        }
        window.addEventListener('unload', cleanupListeners);


        // --- Character Creation ---
        function showCharacterCreator() {
            gameData.isLoading = false; 
            document.getElementById('loadingScreen').classList.add('hidden');
            document.getElementById('characterCreatorScreen').classList.remove('hidden');
            document.getElementById('mainGameScreen').classList.add('hidden');
        }

        async function finalizeCharacterCreation() {
            const houseEl = document.querySelector('input[name="house"]:checked');
            const backgroundEl = document.querySelector('input[name="background"]:checked');
            const charNameInput = document.getElementById('characterNameInput');

            if (!charNameInput || !houseEl || !backgroundEl) {
                addLog("Please fill all character details.", "error");
                return;
            }
            const charName = charNameInput.value.trim();
            if (!charName) {
                 addLog("Please enter a character name.", "error");
                 return;
            }

            // Prepare character details for new document, including online status
            const characterDetailsForNewDoc = {
                name: charName,
                house: houseEl.value,
                background: backgroundEl.value,
                health: 100, maxHealth: 100, attack: 10, defense: 5, level: 1, experience: 0, experienceToNextLevel: 100,
                position: { x: Math.floor(gameData.map.width / 2), y: Math.floor(gameData.map.height / 2) }, 
                equipment: { weapon: null, armor: null, accessory: null },
                guildId: null, 
                isOnline: true, // Set true for new character
                lastSeen: serverTimestamp(), // Set lastSeen for new character
                pvpEnabled: false,
            };
            
            // Update local gameData.character to match what will be saved
            Object.assign(gameData.character, characterDetailsForNewDoc);

            gameData.resources = { spice: 0, water: 50, solari: 200, plasteel: 0, food: 20 }; 
            gameData.inventory = [];
            gameData.map.explored = {};
            gameData.stats = { totalSpiceHarvested: 0, totalSolariEarned: 0, enemiesDefeated: 0, areasExplored: 0, questsCompleted: 0 };
            gameData.buildings = [];
            gameData.units = [];
            gameData.quests = initializePlayerQuests();


            if (gameData.character.house === 'Fremen') { gameData.resources.water += 30; gameData.character.defense += 3; gameData.character.maxHealth += 10; }
            else if (gameData.character.house === 'Harkonnen') { gameData.resources.solari += 150; gameData.character.attack += 3; }
            else if (gameData.character.house === 'Atreides') { gameData.character.maxHealth += 30; gameData.resources.food += 10; }
            else if (gameData.character.house === 'Corrino') { gameData.resources.plasteel += 15; gameData.resources.solari += 75; gameData.character.defense += 1; }

            if (gameData.character.background === 'Merchant') { gameData.resources.solari += 200; }
            else if (gameData.character.background === 'Technician') {
                gameData.resources.plasteel += 10;
                gameData.inventory.push({ id: 'basic_tools', name: 'Basic Toolset', type: 'utility', quantity: 1, description: "A set of tools for basic repairs and crafting." });
            }
            else if (gameData.character.background === 'Scout') { gameData.resources.water += 15; gameData.map.visibleRadius += 1; gameData.resources.food += 5;}
            else if (gameData.character.background === 'Warrior') { gameData.character.attack += 5; gameData.character.defense += 3; gameData.character.maxHealth += 20; }
            gameData.character.health = gameData.character.maxHealth; 

            initializeMapExploration();

            // Pass the fully prepared character object to createNewPlayerDocument
            const success = await createNewPlayerDocument(gameData.character); 
            if (!success) {
                addLog("Failed to save character. Please try again.", "error");
                return; 
            }
            
            gameData.gameInitialized = true; // Mark game as initialized for new player
            document.getElementById('characterCreatorScreen').classList.add('hidden');
            document.getElementById('mainGameScreen').classList.remove('hidden');
            document.getElementById('loadingScreen').classList.add('hidden');
            switchTab('game');
            addLog(`Welcome, ${gameData.character.name} of House ${gameData.character.house}! Your journey on Arrakis begins.`, "event");
            showNarrative("You have arrived on Arrakis, the desert planet. The harsh environment will test your survival skills. Gather resources, build your base, and explore the vast dunes. Interact with other survivors, but be wary of enemies and the great sandworms that roam the deep desert.");

            initializeListeners(); // Initialize listeners for the newly created player
            startGameLoop();
            updateUI();
            generateMapView();
            debouncedSaveGameData(); // Initial save for the new player
        }
        window.finalizeCharacterCreation = finalizeCharacterCreation;


        // --- Game Loop and Core Mechanics ---
        function gameTick() {
            if (!gameData.gameInitialized || gameData.isLoading) return;

            const autoSpicePerTick = gameData.harvesters.spice_harvester_auto_count * (1 + gameData.harvesters.spice_harvester_auto_level * 0.5);
            if (autoSpicePerTick > 0) {
                gameData.resources.spice += autoSpicePerTick;
                gameData.stats.totalSpiceHarvested += autoSpicePerTick;
            }

            const autoWaterPerTick = gameData.harvesters.water_collector_auto_count * (1 + gameData.harvesters.water_collector_auto_level * 0.2);
            if (autoWaterPerTick > 0) gameData.resources.water += autoWaterPerTick;

            gameData.buildings.forEach(b => {
                const buildingDef = STATIC_BUILDINGS.find(sb => sb.id === b.id);
                if (b.level > 0 && buildingDef && buildingDef.production) {
                    for (const resource in buildingDef.production) {
                        gameData.resources[resource] += buildingDef.production[resource] * b.level;
                        if (resource === 'spice') gameData.stats.totalSpiceHarvested += buildingDef.production[resource] * b.level;
                    }
                }
            });

            gameData.units.forEach(u => {
                const unitDef = STATIC_UNITS.find(su => su.id === u.id);
                if (u.count > 0 && unitDef && unitDef.upkeep) {
                    for (const resource in unitDef.upkeep) {
                        gameData.resources[resource] -= unitDef.upkeep[resource] * u.count;
                        if (gameData.resources[resource] < 0) gameData.resources[resource] = 0;
                    }
                }
            });
            
            if (Math.random() < 0.1) { 
                let waterConsumed = 0.2; 
                const stillsuit = gameData.character.equipment.armor;
                if (stillsuit && stillsuit.id === 'stillsuit') waterConsumed *= 0.5; 
                gameData.resources.water -= waterConsumed;
                if (gameData.resources.water < 0) {
                    gameData.resources.water = 0;
                    gameData.character.health -= 1; 
                    if (gameData.character.health <= 0) {
                        playerDefeated("Dehydration");
                    }
                }
            }


            if (gameData.combat.inCombat) {
            }

            if (Math.random() < 0.005) { 
                const events = [
                    { msg: "A small tremor reveals a pocket of Spice!", spice: 10 + (5 * gameData.harvesters.spice_harvester_auto_level), type: "event" },
                    { msg: "A Fremen trader offers a small discount on water.", type: "lore" }, 
                ];
                const randomEvent = events[Math.floor(Math.random() * events.length)];
                addLog(randomEvent.msg, randomEvent.type);
                if(randomEvent.spice) gameData.resources.spice += randomEvent.spice;
            }

            updateUI(); 
        }

        let gameLoopInterval = null;
        function startGameLoop() {
            if (!gameData.gameInitialized) return; // Don't start if not initialized
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameTick, gameData.settings.gameSpeed);
        }

        function manualHarvestSpice() {
            if (!gameData.gameInitialized) return;
            const amount = 1 + Math.floor(gameData.harvesters.spice_harvester_manual_level * 1.5);
            gameData.resources.spice += amount;
            gameData.stats.totalSpiceHarvested += amount;
            addLog(`Manually harvested ${amount} Spice.`, "action");
            updateQuestProgress('resource', amount, 'spice');
            updateUI();
            debouncedSaveGameData();
        }
        window.manualHarvestSpice = manualHarvestSpice;


        function buyAutoHarvester(type) {
            let cost, costField, countField, levelField, logMsg;
            if (type === 'spice') {
                cost = gameData.upgrades.spice_auto_cost;
                if (gameData.resources.solari >= cost) {
                    gameData.resources.solari -= cost;
                    gameData.harvesters.spice_harvester_auto_count++;
                    gameData.upgrades.spice_auto_cost = Math.ceil(cost * 1.25);
                    logMsg = "Purchased Spice Auto-Harvester.";
                } else { addLog("Not enough Solari.", "error"); return; }
            } else if (type === 'water') {
                cost = gameData.upgrades.water_auto_cost;
                 if (gameData.resources.solari >= cost) {
                    gameData.resources.solari -= cost;
                    gameData.harvesters.water_collector_auto_count++;
                    gameData.upgrades.water_auto_cost = Math.ceil(cost * 1.3);
                    logMsg = "Purchased Water Auto-Collector.";
                } else { addLog("Not enough Solari.", "error"); return; }
            }
            addLog(logMsg, "success");
            updateUI();
            debouncedSaveGameData();
        }
        window.buyAutoHarvester = buyAutoHarvester;

        function upgradeManualSpiceHarvester() {
            const cost = gameData.upgrades.spice_manual_upgrade_cost;
            if (gameData.resources.solari >= cost) {
                gameData.resources.solari -= cost;
                gameData.harvesters.spice_harvester_manual_level++;
                gameData.upgrades.spice_manual_upgrade_cost = Math.ceil(cost * 1.7);
                addLog("Manual Spice Harvesting upgraded!", "success");
            } else {
                 addLog("Not enough Solari.", "error");
            }
            updateUI();
            debouncedSaveGameData();
        }
        window.upgradeManualSpiceHarvester = upgradeManualSpiceHarvester;

        function upgradeAutoHarvester(type) {
            let cost = 0;
            let currentLevel, currentCount;
            if (type === 'spice') {
                currentLevel = gameData.harvesters.spice_harvester_auto_level;
                currentCount = gameData.harvesters.spice_harvester_auto_count;
                if (currentCount === 0) { addLog("Buy a Spice Auto-Harvester first!", "warn"); return; }
                cost = 75 * Math.pow(1.8, currentLevel) * currentCount; 
                if (gameData.resources.solari >= cost) {
                    gameData.resources.solari -= cost;
                    gameData.harvesters.spice_harvester_auto_level++;
                    addLog("Spice Auto-Harvester efficiency upgraded!", "success");
                } else { addLog("Not enough Solari for upgrade.", "error"); }
            } else if (type === 'water') {
                currentLevel = gameData.harvesters.water_collector_auto_level;
                currentCount = gameData.harvesters.water_collector_auto_count;
                if (currentCount === 0) { addLog("Buy a Water Auto-Collector first!", "warn"); return; }
                cost = 100 * Math.pow(1.9, currentLevel) * currentCount;
                 if (gameData.resources.solari >= cost) {
                    gameData.resources.solari -= cost;
                    gameData.harvesters.water_collector_auto_level++;
                    addLog("Water Auto-Collector efficiency upgraded!", "success");
                } else { addLog("Not enough Solari for upgrade.", "error"); }
            }
            updateUI();
            debouncedSaveGameData();
        }
        window.upgradeAutoHarvester = upgradeAutoHarvester;


        // --- Map and Movement ---
        function initializeMapExploration() {
            const pos = gameData.character.position;
            markAreaAsExplored(pos.x, pos.y); 
            for (let dx = -gameData.map.visibleRadius; dx <= gameData.map.visibleRadius; dx++) {
                for (let dy = -gameData.map.visibleRadius; dy <= gameData.map.visibleRadius; dy++) {
                    if (Math.sqrt(dx*dx + dy*dy) <= gameData.map.visibleRadius) {
                         markAreaAsExplored(pos.x + dx, pos.y + dy);
                    }
                }
            }
            generateInitialMapResources(); 
            generateInitialMapEnemies(15); 
        }

        function markAreaAsExplored(x, y) {
            if (x < 0 || x >= gameData.map.width || y < 0 || y >= gameData.map.height) return;
            const key = `${x},${y}`;
            if (!gameData.map.explored[key]) {
                gameData.map.explored[key] = true;
                gameData.stats.areasExplored++;
                updateQuestProgress('explore', 1);
            }
        }
        async function generateInitialMapResources() {
            if (!db) return;
            const resourcesColRef = collection(db, 'artifacts', appId, 'public', 'mapResources');
            const q = query(resourcesColRef, where("appId", "==", appId));
            const existingResourcesSnap = await getDocs(q);


            if (existingResourcesSnap.empty) {
                const batch = writeBatch(db);
                const numResourceNodes = Math.floor((gameData.map.width * gameData.map.height) / 50); 
                for (let i = 0; i < numResourceNodes; i++) {
                    const rX = Math.floor(Math.random() * gameData.map.width);
                    const rY = Math.floor(Math.random() * gameData.map.height);
                    const rType = Math.random() < 0.6 ? 'spice' : (Math.random() < 0.7 ? 'water' : 'plasteel_vein');
                    const rAmount = rType === 'spice' ? (Math.floor(Math.random() * 50) + 50) : (rType === 'water' ? Math.floor(Math.random() * 30) + 20 : Math.floor(Math.random() * 20) + 10);
                    const resourceNode = {
                        x: rX, y: rY, type: rType, initialAmount: rAmount, currentAmount: rAmount,
                        appId: appId, 
                        lastHarvested: null, regenerationTime: serverTimestamp() 
                    };
                    const newResourceRef = doc(collection(db, 'artifacts', appId, 'public', 'mapResources'));
                    batch.set(newResourceRef, resourceNode);
                }
                try {
                    await batch.commit();
                    console.log(`${numResourceNodes} initial map resources generated and saved to Firestore.`);
                } catch (error) {
                    console.error("Error generating initial map resources:", error);
                }
            } else {
                console.log("Map resources already exist in Firestore.");
            }
        }
        async function generateInitialMapEnemies(count) {
            if (!db) return;
            const enemiesColRef = collection(db, 'artifacts', appId, 'public', 'mapEnemies');
            const q = query(enemiesColRef, where("appId", "==", appId));
            const existingEnemiesSnap = await getDocs(q);

            if (existingEnemiesSnap.empty) { 
                const batch = writeBatch(db);
                for (let i = 0; i < count; i++) {
                    const enemyType = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
                    const x = Math.floor(Math.random() * gameData.map.width);
                    const y = Math.floor(Math.random() * gameData.map.height);

                    if ( (x > gameData.map.width/2 - 5 && x < gameData.map.width/2 + 5 && y > gameData.map.height/2 - 5 && y < gameData.map.height/2 + 5) ||
                         gameData.map.locations.some(loc => loc.x === x && loc.y ===y && loc.friendly) ) {
                        i--; continue;
                    }

                    const enemyDocRef = doc(collection(db, 'artifacts', appId, 'public', 'mapEnemies'));
                    batch.set(enemyDocRef, {
                        ...enemyType, 
                        currentHealth: enemyType.health,
                        position: { x, y },
                        appId: appId,
                        lastAttacked: null,
                        respawnTime: null
                    });
                }
                try {
                    await batch.commit();
                    console.log(`${count} initial map enemies generated.`);
                } catch (error) {
                    console.error("Error generating initial map enemies:", error);
                }
            } else {
                console.log("Initial map enemies already exist.");
            }
        }


        function moveCharacter(direction) {
            if (gameData.combat.inCombat) { addLog("Cannot move while in combat!", "error"); return; }

            const pos = gameData.character.position;
            let newX = pos.x, newY = pos.y;

            if (direction === 'north') newY = Math.max(0, pos.y - 1);
            else if (direction === 'south') newY = Math.min(gameData.map.height - 1, pos.y + 1);
            else if (direction === 'west') newX = Math.max(0, pos.x - 1);
            else if (direction === 'east') newX = Math.min(gameData.map.width - 1, pos.x + 1);
            else if (direction.x !== undefined && direction.y !== undefined) { 
                newX = parseInt(direction.x);
                newY = parseInt(direction.y);
                if (Math.abs(newX - pos.x) > 1 || Math.abs(newY - pos.y) > 1) {
                    addLog("You can only move to adjacent cells by clicking.", "warn");
                    return;
                }
            }

            const waterCost = 1; 
            if (gameData.resources.water < waterCost) { addLog("Not enough water to travel!", "error"); return; }
            gameData.resources.water -= waterCost;

            gameData.character.position = { x: newX, y: newY };
            addLog(`Moved to (${newX},${newY}). Used ${waterCost} water.`, "action");

            markAreaAsExplored(newX, newY);
            for (let dx = -gameData.map.visibleRadius; dx <= gameData.map.visibleRadius; dx++) {
                for (let dy = -gameData.map.visibleRadius; dy <= gameData.map.visibleRadius; dy++) {
                     if (Math.sqrt(dx*dx + dy*dy) <= gameData.map.visibleRadius) { 
                        markAreaAsExplored(newX + dx, newY + dy);
                    }
                }
            }

            checkForEncounters(); 
            updateUI();
            generateMapView(); 
            updatePlayerDocument({ 
                "character.position": gameData.character.position,
                "character.lastSeen": serverTimestamp() 
            }); 
            debouncedSaveGameData(); 
        }
        window.moveCharacter = moveCharacter;

        async function gatherResourceNode(resourceId) {
            if (!db || !userId) return;
            const resourceNodeRef = doc(db, 'artifacts', appId, 'public', 'mapResources', resourceId);


            try {
                const docSnap = await getDoc(resourceNodeRef);
                if (!docSnap.exists()) {
                    addLog("Resource node not found or depleted.", "error");
                    return;
                }
                const nodeData = docSnap.data();
                const playerPos = gameData.character.position;

                if (Math.abs(playerPos.x - nodeData.x) > 1 || Math.abs(playerPos.y - nodeData.y) > 1) {
                    addLog("You are too far to gather from this node.", "warn");
                    return;
                }

                if (nodeData.currentAmount <= 0) {
                    addLog(`${nodeData.type} node is depleted.`, "info");
                    return;
                }

                const gatherAmount = Math.min(nodeData.currentAmount, Math.floor(Math.random() * 5) + 5 + gameData.harvesters.spice_harvester_manual_level); 
                const newAmount = nodeData.currentAmount - gatherAmount;

                gameData.resources[nodeData.type] = (gameData.resources[nodeData.type] || 0) + gatherAmount;
                addLog(`Gathered ${gatherAmount} ${nodeData.type}.`, "success");

                if (nodeData.type === 'spice') gameData.stats.totalSpiceHarvested += gatherAmount;
                updateQuestProgress('resource', gatherAmount, nodeData.type);


                if (newAmount <= 0) {
                    await updateDoc(resourceNodeRef, {
                        currentAmount: 0,
                        lastHarvested: serverTimestamp(),
                        regenerationTime: serverTimestamp() 
                    });
                    addLog(`The ${nodeData.type} node has been depleted. It will regenerate over time.`, "info");
                    gameData.map.map_resources = gameData.map.map_resources.filter(r => r.id !== resourceId);

                } else {
                    await updateDoc(resourceNodeRef, { currentAmount: newAmount, lastHarvested: serverTimestamp() });
                }
                updateUI();
                generateMapView();
                debouncedSaveGameData();

            } catch (error) {
                console.error("Error gathering resource node:", error);
                addLog("Error gathering resource. Try again.", "error");
            }
        }
        window.gatherResourceNode = gatherResourceNode;


        // --- UI Update Functions ---
        function switchTab(tabId) {
            const allTabs = document.querySelectorAll('.main-tab-content');
            allTabs.forEach(tab => tab.classList.add('hidden'));
            const activeTab = document.getElementById(tabId + 'Screen');
            if (activeTab) {
                activeTab.classList.remove('hidden');
            } else {
                console.warn(`Tab content for ${tabId}Screen not found!`);
                document.getElementById('gameScreen').classList.remove('hidden'); 
            }


            const allButtons = document.querySelectorAll('.tab-button');
            allButtons.forEach(button => button.classList.remove('active', 'border-amber-500', 'text-amber-500')); 
            allButtons.forEach(button => button.classList.add('text-stone-400', 'hover:text-amber-300', 'border-transparent'));


            const activeButton = document.querySelector(`.tab-button[onclick="switchTab('${tabId}')"]`);
            if (activeButton) {
                activeButton.classList.add('active', 'border-amber-500', 'text-amber-500');
                activeButton.classList.remove('text-stone-400', 'hover:text-amber-300', 'border-transparent');
            }
            gameData.currentTab = tabId;
            if (tabId === 'map') generateMapView();
            if (tabId === 'multiplayer') {
                updateChatDisplay();
                updateGuildDisplay();
                updatePlayerTracker();
                updateWorldEventsDisplay();
            }
            if (tabId === 'quests') updateQuestsDisplay();
            if (tabId === 'inventory') updateInventoryDisplay();
            if (tabId === 'buildings') updateBuildingsDisplay();
            if (tabId === 'units') updateUnitsDisplay();
            if (tabId === 'crafting') updateCraftingDisplay();

        }
        window.switchTab = switchTab;


        function updateUI() {
            if (!gameData.gameInitialized && !gameData.isLoading) return;
            if (gameData.isLoading) {
                 document.getElementById('loadingScreen').classList.remove('hidden');
                 document.getElementById('mainGameScreen').classList.add('hidden');
                 document.getElementById('characterCreatorScreen').classList.add('hidden');
                 return;
            } else {
                document.getElementById('loadingScreen').classList.add('hidden');
                if (gameData.gameInitialized) {
                    document.getElementById('mainGameScreen').classList.remove('hidden');
                    document.getElementById('characterCreatorScreen').classList.add('hidden');
                    const userIdDisplayEl = document.getElementById('userIdDisplay');
                    if (userId && userIdDisplayEl) userIdDisplayEl.textContent = userId; 
                } else {
                    document.getElementById('mainGameScreen').classList.add('hidden');
                    document.getElementById('characterCreatorScreen').classList.remove('hidden');
                    return; 
                }
            }


            document.getElementById('spiceDisplay').textContent = Math.floor(gameData.resources.spice);
            document.getElementById('waterDisplay').textContent = Math.floor(gameData.resources.water);
            document.getElementById('solariDisplay').textContent = Math.floor(gameData.resources.solari);
            document.getElementById('plasteelDisplay').textContent = Math.floor(gameData.resources.plasteel);
            document.getElementById('foodDisplay').textContent = Math.floor(gameData.resources.food);

            if (document.getElementById('characterNameDisplay')) { 
                document.getElementById('characterNameDisplay').textContent = gameData.character.name;
                document.getElementById('characterHouseDisplay').textContent = gameData.character.house || 'N/A';
                document.getElementById('characterBackgroundDisplay').textContent = gameData.character.background || 'N/A';
                document.getElementById('characterLevelDisplay').textContent = gameData.character.level;
                document.getElementById('characterExpDisplay').textContent = `${gameData.character.experience} / ${gameData.character.experienceToNextLevel}`;
                document.getElementById('characterAttackDisplay').textContent = gameData.character.attack;
                document.getElementById('characterDefenseDisplay').textContent = gameData.character.defense;

                const healthPercentage = (gameData.character.health / gameData.character.maxHealth) * 100;
                document.getElementById('healthDisplay').textContent = `${Math.floor(gameData.character.health)} / ${gameData.character.maxHealth}`;
                document.getElementById('healthBarFill').style.width = `${healthPercentage}%`;

                document.getElementById('healthDisplayMain').textContent = `${Math.floor(gameData.character.health)} / ${gameData.character.maxHealth}`;
                document.getElementById('healthBarFillMain').style.width = `${healthPercentage}%`;

                const pvpToggle = document.getElementById('pvpToggle');
                if (pvpToggle) pvpToggle.checked = gameData.character.pvpEnabled;

            }

            if (document.getElementById('manualSpiceLevel')) {
                document.getElementById('manualSpiceLevel').textContent = gameData.harvesters.spice_harvester_manual_level;
                document.getElementById('manualSpiceUpgradeCost').textContent = gameData.upgrades.spice_manual_upgrade_cost;
                document.getElementById('autoSpiceCount').textContent = gameData.harvesters.spice_harvester_auto_count;
                document.getElementById('autoSpiceLevel').textContent = gameData.harvesters.spice_harvester_auto_level;
                document.getElementById('autoSpiceCost').textContent = gameData.upgrades.spice_auto_cost;
                document.getElementById('autoWaterCount').textContent = gameData.harvesters.water_collector_auto_count;
                document.getElementById('autoWaterLevel').textContent = gameData.harvesters.water_collector_auto_level;
                document.getElementById('autoWaterCost').textContent = gameData.upgrades.water_auto_cost;

                const spiceUpgradeEffCost = gameData.harvesters.spice_harvester_auto_count > 0 ? Math.ceil(75 * Math.pow(1.8, gameData.harvesters.spice_harvester_auto_level) * gameData.harvesters.spice_harvester_auto_count) : 'N/A';
                document.getElementById('autoSpiceUpgradeEffCost').textContent = spiceUpgradeEffCost;
                const waterUpgradeEffCost = gameData.harvesters.water_collector_auto_count > 0 ? Math.ceil(100 * Math.pow(1.9, gameData.harvesters.water_collector_auto_level) * gameData.harvesters.water_collector_auto_count) : 'N/A';
                document.getElementById('autoWaterUpgradeEffCost').textContent = waterUpgradeEffCost;
            }

            if (gameData.currentTab === 'buildings') updateBuildingsDisplay();
            if (gameData.currentTab === 'units') updateUnitsDisplay();
            if (gameData.currentTab === 'crafting') updateCraftingDisplay();
            if (gameData.currentTab === 'inventory') updateInventoryDisplay();
            if (gameData.currentTab === 'quests') updateQuestsDisplay();
            if (gameData.currentTab === 'multiplayer') {
                updateChatDisplay();
                updateGuildDisplay();
                updatePlayerTracker();
                updateWorldEventsDisplay();
            }
            if (gameData.currentTab === 'map') {
                 generateMapView();
                 document.getElementById('mapPlayerX').textContent = gameData.character.position.x;
                 document.getElementById('mapPlayerY').textContent = gameData.character.position.y;
            }
        }

        function updateBuildingsDisplay() {
            const container = document.getElementById('buildingsList');
            if (!container) return;
            container.innerHTML = '';
            STATIC_BUILDINGS.forEach(def => {
                const playerBuilding = gameData.buildings.find(b => b.id === def.id) || { id: def.id, level: 0 };
                const currentLevel = playerBuilding.level;
                const cost = currentLevel === 0 ? def.cost : Object.entries(def.cost).reduce((acc, [key, val]) => {
                    acc[key] = Math.ceil(val * Math.pow(def.upgradeCostFactor, currentLevel)); return acc;
                }, {});
                const costString = Object.entries(cost).map(([res, val]) => `${val} ${res}`).join(', ');

                const card = document.createElement('div');
                card.className = 'bg-stone-700 p-4 rounded-lg shadow';
                card.innerHTML = `
                    <h3 class="text-lg font-semibold text-amber-400 mb-1">${def.name} (Lvl ${currentLevel})</h3>
                    <p class="text-xs text-stone-300 mb-1">${def.description}</p>
                    ${currentLevel < def.maxLevel ? `
                        <p class="text-xs text-stone-300 mb-2">Cost to ${currentLevel === 0 ? 'Build' : 'Upgrade'}: ${costString}</p>
                        <button onclick="buildStructure('${def.id}')" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-md text-sm transition-colors">
                            ${currentLevel === 0 ? 'Build' : 'Upgrade'}
                        </button>
                    ` : '<p class="text-sm text-green-400">Max Level Reached</p>'}
                    ${def.production ? `<p class="text-xs text-stone-400 mt-1">Produces: ${Object.entries(def.production).map(([res,val]) => `${val*currentLevel} ${res}/tick`).join(', ')}</p>` : ''}
                `;
                container.appendChild(card);
            });
        }
        window.buildStructure = (buildingId) => {
            const def = STATIC_BUILDINGS.find(b => b.id === buildingId);
            if (!def) { addLog("Invalid building.", "error"); return; }

            let playerBuilding = gameData.buildings.find(b => b.id === buildingId);
            if (!playerBuilding) {
                playerBuilding = { id: buildingId, level: 0 };
                gameData.buildings.push(playerBuilding);
            }

            if (playerBuilding.level >= def.maxLevel) { addLog(`${def.name} at max level.`, "info"); return; }

            const cost = playerBuilding.level === 0 ? def.cost : Object.entries(def.cost).reduce((acc, [key, val]) => {
                acc[key] = Math.ceil(val * Math.pow(def.upgradeCostFactor, playerBuilding.level)); return acc;
            }, {});

            for (const resource in cost) {
                if (gameData.resources[resource] < cost[resource]) {
                    addLog(`Not enough ${resource}.`, "error"); return;
                }
            }
            for (const resource in cost) { gameData.resources[resource] -= cost[resource]; }

            playerBuilding.level++;
            addLog(`${playerBuilding.level === 1 ? 'Built' : 'Upgraded'} ${def.name} to Lvl ${playerBuilding.level}!`, "success");
            updateQuestProgress('build', 1, buildingId);
            updateUI();
            debouncedSaveGameData();
        };

        function updateUnitsDisplay() {
            const container = document.getElementById('unitsList');
            if (!container) return;
            container.innerHTML = '';
            STATIC_UNITS.forEach(def => {
                const playerUnit = gameData.units.find(u => u.id === def.id) || { id: def.id, count: 0 };
                const costString = Object.entries(def.cost).map(([res, val]) => `${val} ${res}`).join(', ');
                const upkeepString = def.upkeep ? `Upkeep: ${Object.entries(def.upkeep).map(([res,val]) => `${val} ${res}/tick`).join(', ')}` : '';

                const card = document.createElement('div');
                card.className = 'bg-stone-700 p-4 rounded-lg shadow';
                card.innerHTML = `
                    <h3 class="text-lg font-semibold text-amber-400 mb-1">${def.name} (Count: ${playerUnit.count})</h3>
                    <p class="text-xs text-stone-300 mb-1">${def.description}</p>
                    <p class="text-xs text-stone-300 mb-2">Cost to Train: ${costString}</p>
                    ${upkeepString ? `<p class="text-xs text-stone-400 mb-2">${upkeepString}</p>` : ''}
                    <button onclick="trainUnit('${def.id}')" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-3 rounded-md text-sm transition-colors">Train Unit</button>
                `;
                container.appendChild(card);
            });
        }
        window.trainUnit = (unitId) => {
            const def = STATIC_UNITS.find(u => u.id === unitId);
            if (!def) { addLog("Invalid unit.", "error"); return; }

            const barracks = gameData.buildings.find(b => b.id === 'barracks' && b.level > 0);
            if (!barracks && def.id !== 'scout_unit') { 
                addLog("Build Barracks to train combat units.", "warn"); return;
            }

            for (const resource in def.cost) {
                if (gameData.resources[resource] < def.cost[resource]) {
                    addLog(`Not enough ${resource}.`, "error"); return;
                }
            }
            for (const resource in def.cost) { gameData.resources[resource] -= def.cost[resource]; }

            let playerUnit = gameData.units.find(u => u.id === unitId);
            if (!playerUnit) {
                playerUnit = { id: unitId, count: 0 };
                gameData.units.push(playerUnit);
            }
            playerUnit.count++;
            addLog(`Trained 1 ${def.name}.`, "success");
            updateUI();
            debouncedSaveGameData();
        };


        function updateCraftingDisplay() {
            const container = document.getElementById('craftingRecipesList');
            if (!container) return;
            container.innerHTML = '';
            gameData.craftingRecipes.forEach(recipe => {
                const costString = Object.entries(recipe.cost).map(([res, val]) => `${val} ${res}`).join(', ');
                const card = document.createElement('div');
                card.className = 'bg-stone-700 p-4 rounded-lg shadow';
                card.innerHTML = `
                    <h3 class="text-lg font-semibold text-amber-400 mb-1">${recipe.name}</h3>
                    <p class="text-xs text-stone-300 mb-1">${recipe.description}</p>
                    <p class="text-xs text-stone-300 mb-2">Cost: ${costString}</p>
                    <p class="text-xs text-stone-300 mb-2">Output: ${recipe.output.quantity}x ${recipe.output.name}</p>
                    <button onclick="craftItem('${recipe.id}')" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-3 rounded-md text-sm transition-colors">Craft</button>
                `;
                container.appendChild(card);
            });
        }
        window.craftItem = (recipeId) => {
            const recipe = gameData.craftingRecipes.find(r => r.id === recipeId);
            if (!recipe) { addLog("Invalid recipe.", "error"); return; }

            for (const resource in recipe.cost) {
                if (gameData.resources[resource] < recipe.cost[resource]) {
                    addLog(`Not enough ${resource}.`, "error"); return;
                }
            }
            for (const resource in recipe.cost) { gameData.resources[resource] -= recipe.cost[resource]; }

            const existingItem = gameData.inventory.find(item => item.id === recipe.output.id);
            if (existingItem) {
                existingItem.quantity = (existingItem.quantity || 0) + recipe.output.quantity;
            } else {
                gameData.inventory.push({ ...recipe.output });
            }
            addLog(`Crafted ${recipe.output.quantity}x ${recipe.name}.`, "success");
            updateQuestProgress('craft', recipe.output.quantity, recipe.id);
            updateUI();
            debouncedSaveGameData();
        };

        function updateInventoryDisplay() {
            const container = document.getElementById('inventoryList');
            if (!container) return;
            container.innerHTML = '';
            if (gameData.inventory.length === 0) {
                container.innerHTML = '<p class="text-stone-400 text-center">Your inventory is empty.</p>';
            } else {
                gameData.inventory.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'bg-stone-700 p-3 rounded-lg shadow flex justify-between items-center';
                    card.innerHTML = `
                        <div>
                            <h3 class="text-md font-semibold text-amber-300">${item.name} (x${item.quantity})</h3>
                            <p class="text-xs text-stone-400">${item.description || item.type}</p>
                        </div>
                        <div>
                        ${item.type === 'consumable' ? `<button onclick="useItem('${item.id}')" class="bg-green-500 hover:bg-green-600 text-white text-xs py-1 px-2 rounded-md ml-2">Use</button>` : ''}
                        ${['weapon', 'armor', 'accessory'].includes(item.type) ? `<button onclick="equipItem('${item.id}')" class="bg-sky-500 hover:bg-sky-600 text-white text-xs py-1 px-2 rounded-md ml-2">Equip</button>` : ''}
                        </div>
                    `;
                    container.appendChild(card);
                });
            }
            
            const equippedContainer = document.getElementById('equippedItemsDisplay'); 
            if (equippedContainer) {
                equippedContainer.innerHTML = '<h3 class="text-lg font-semibold text-amber-400 mb-2">Equipped Gear</h3>';
                let hasEquipped = false;
                Object.entries(gameData.character.equipment).forEach(([slot, item]) => {
                    if (item) {
                        equippedContainer.innerHTML += `<p class="text-sm text-stone-300 capitalize">${slot}: ${item.name}</p>`;
                        hasEquipped = true;
                    }
                });
                if (!hasEquipped) {
                    equippedContainer.innerHTML += '<p class="text-sm text-stone-400">No gear equipped.</p>';
                }
            }
        }
        window.useItem = (itemId) => { 
            const itemIndex = gameData.inventory.findIndex(item => item.id === itemId);
            if (itemIndex === -1 || gameData.inventory[itemIndex].quantity <= 0) {
                addLog("No such item.", "error"); return;
            }
            const item = gameData.inventory[itemIndex];
            let itemUsed = false;

            if (item.type === 'consumable' && item.effect) {
                if (item.effect.health && gameData.character.health < gameData.character.maxHealth) {
                    gameData.character.health = Math.min(gameData.character.maxHealth, gameData.character.health + item.effect.health);
                    itemUsed = true;
                } else if (item.effect.food) {
                    gameData.resources.food += item.effect.food;
                    itemUsed = true;
                } 
                if (itemUsed) addLog(`Used ${item.name}.`, "action");
                else addLog("Cannot use now.", "info");
            }

            if (itemUsed) {
                item.quantity--;
                if (item.quantity <= 0) gameData.inventory.splice(itemIndex, 1);
                updateUI();
                debouncedSaveGameData();
            }
        };
        window.equipItem = (itemId) => { 
            const itemIndex = gameData.inventory.findIndex(i => i.id === itemId);
            if (itemIndex === -1) { addLog("Item not found.", "error"); return; }
            const itemToEquip = gameData.inventory[itemIndex];

            const itemType = itemToEquip.type; 
            if (!['weapon', 'armor', 'accessory'].includes(itemType)) {
                addLog("This item cannot be equipped.", "warn"); return;
            }

            const currentEquipped = gameData.character.equipment[itemType];
            if (currentEquipped) {
                const existingInvItem = gameData.inventory.find(i => i.id === currentEquipped.id);
                if (existingInvItem) existingInvItem.quantity++;
                else gameData.inventory.push({...currentEquipped, quantity: 1});
            }

            gameData.character.equipment[itemType] = { ...itemToEquip, quantity: undefined }; 
            itemToEquip.quantity--;
            if (itemToEquip.quantity <= 0) gameData.inventory.splice(itemIndex, 1);

            recalculateCharacterStats();
            addLog(`Equipped ${itemToEquip.name}.`, "action");
            updateUI();
            debouncedSaveGameData();
        };

        function recalculateCharacterStats() {
            let baseAttack = 10 + (gameData.character.level -1) * 2;
            let baseDefense = 5 + (gameData.character.level -1) * 1;
            let baseMaxHealth = 100 + (gameData.character.level-1) * 10;

            if (gameData.character.house === 'Fremen') { baseDefense += 3; baseMaxHealth += 10; }
            else if (gameData.character.house === 'Harkonnen') { baseAttack += 3; }
            else if (gameData.character.house === 'Atreides') { baseMaxHealth += 30; }
            else if (gameData.character.house === 'Corrino') { baseDefense += 1; }

            if (gameData.character.background === 'Warrior') { baseAttack += 5; baseDefense += 3; baseMaxHealth += 20;}
            
            gameData.character.attack = baseAttack;
            gameData.character.defense = baseDefense;
            gameData.character.maxHealth = baseMaxHealth;

            Object.values(gameData.character.equipment).forEach(item => {
                if (item && item.stats) {
                    if (item.stats.attack) gameData.character.attack += item.stats.attack;
                    if (item.stats.defense) gameData.character.defense += item.stats.defense;
                    if (item.stats.maxHealth) gameData.character.maxHealth += item.stats.maxHealth;
                }
            });
            gameData.character.health = Math.min(gameData.character.health, gameData.character.maxHealth); 
        }


        function updateQuestsDisplay() {
            const container = document.getElementById('questsList');
            if (!container) return;
            container.innerHTML = '';
            const activeQuests = gameData.quests.filter(q => q.active && !q.completed);
            const completedQuests = gameData.quests.filter(q => q.completed);

            if (activeQuests.length === 0 && completedQuests.length === 0) {
                 container.innerHTML = '<p class="text-stone-400 text-center">No quests available yet. Explore to find new challenges!</p>';
                 return;
            }

            activeQuests.forEach(playerQuest => {
                const def = STATIC_QUESTS.find(q => q.id === playerQuest.questId);
                if (!def) return;
                const card = document.createElement('div');
                card.className = 'bg-stone-700 p-3 rounded-lg shadow';
                let objectivesHtml = '<ul class="list-disc list-inside text-xs text-stone-300 space-y-1 mt-1">';
                def.objectives.forEach(objDef => {
                    const playerObj = playerQuest.objectives[objDef.id];
                    const progress = playerObj.progress || 0;
                    let isCompleted = playerObj.completed;
                    if (!isCompleted && objDef.target === 'resource' && gameData.resources[objDef.resourceType] !== undefined) {
                        isCompleted = gameData.resources[objDef.resourceType] >= objDef.amount;
                        if (isCompleted) playerObj.completed = true; 
                    }


                    objectivesHtml += `<li class="${isCompleted ? 'text-green-400 line-through' : ''}">${objDef.description} ${objDef.amount > 1 ? `(${isCompleted ? objDef.amount : progress}/${objDef.amount})` : ''}</li>`;
                });
                objectivesHtml += '</ul>';

                card.innerHTML = `
                    <h3 class="text-md font-semibold text-amber-300">${def.title}</h3>
                    <p class="text-xs text-stone-400 mb-1">${def.description}</p>
                    ${objectivesHtml}
                `;
                container.appendChild(card);
            });

            if (completedQuests.length > 0) {
                container.innerHTML += '<h3 class="text-lg font-semibold text-green-400 mt-4 mb-2">Completed Quests</h3>';
                completedQuests.forEach(playerQuest => {
                     const def = STATIC_QUESTS.find(q => q.id === playerQuest.questId);
                     if (!def) return;
                     container.innerHTML += `<p class="text-sm text-stone-400 line-through">${def.title}</p>`;
                });
            }
        }

        function updateQuestProgress(targetType, amount, detail = null) { 
            let questUpdated = false;
            gameData.quests.forEach(playerQuest => {
                if (!playerQuest.active || playerQuest.completed) return;
                const questDef = STATIC_QUESTS.find(q => q.id === playerQuest.questId);
                if (!questDef) return;

                let allObjectivesComplete = true;
                questDef.objectives.forEach(objDef => {
                    const playerObj = playerQuest.objectives[objDef.id];
                    if (playerObj.completed) return; 

                    if (objDef.target === targetType) {
                        let match = false;
                        if (targetType === 'resource' && objDef.resourceType === detail) match = true;
                        else if (targetType === 'craft' && objDef.itemId === detail) match = true;
                        else if (targetType === 'build' && objDef.buildingId === detail) match = true;
                        else if (targetType === 'explore' || targetType === 'combat' || (targetType === 'visit_location' && objDef.locationName === detail)) match = true;


                        if (match) {
                            playerObj.progress = (playerObj.progress || 0) + amount;
                            if (playerObj.progress >= objDef.amount) {
                                playerObj.completed = true;
                                addLog(`Objective complete: ${objDef.description}`, "event");
                            }
                            questUpdated = true;
                        }
                    }
                    if (!playerObj.completed) allObjectivesComplete = false;
                });

                if (allObjectivesComplete) {
                    playerQuest.completed = true;
                    playerQuest.active = false; 
                    addLog(`Quest Completed: ${questDef.title}!`, "success");
                    gameData.stats.questsCompleted++;
                    if (questDef.rewards.solari) gameData.resources.solari += questDef.rewards.solari;
                    if (questDef.rewards.spice) gameData.resources.spice += questDef.rewards.spice;
                    if (questDef.rewards.plasteel) gameData.resources.plasteel += questDef.rewards.plasteel;
                    if (questDef.rewards.experience) {
                        gameData.character.experience += questDef.rewards.experience;
                        checkLevelUp();
                    }
                    if (questDef.rewards.item) {
                         const existingItem = gameData.inventory.find(i => i.id === questDef.rewards.item.id);
                         if (existingItem) existingInvItem.quantity = (existingInvItem.quantity || 0) + (questDef.rewards.item.quantity || 1);
                         else gameData.inventory.push({...questDef.rewards.item, quantity: (questDef.rewards.item.quantity || 1)});
                         addLog(`Received item: ${questDef.rewards.item.name}`, "success");
                    }
                    activateNextQuests(playerQuest.questId); 
                }
            });
            if (questUpdated) {
                updateUI(); 
                debouncedSaveGameData();
            }
        }

        function activateNextQuests(completedQuestId) {
            const completedNum = parseInt(completedQuestId.substring(1));
            const nextQuestId = `q${completedNum + 1}`;
            const nextPlayerQuest = gameData.quests.find(pq => pq.questId === nextQuestId);
            if (nextPlayerQuest && !nextPlayerQuest.active && !nextPlayerQuest.completed) {
                nextPlayerQuest.active = true;
                const nextQuestDef = STATIC_QUESTS.find(sq => sq.id === nextQuestId);
                if (nextQuestDef) addLog(`New quest available: ${nextQuestDef.title}`, "event");
            }
        }

        function checkLevelUp() {
            while (gameData.character.experience >= gameData.character.experienceToNextLevel) {
                gameData.character.level++;
                gameData.character.experience -= gameData.character.experienceToNextLevel;
                gameData.character.experienceToNextLevel = Math.floor(gameData.character.experienceToNextLevel * 1.6); 

                gameData.character.maxHealth += 15 + Math.floor(gameData.character.level * 1.5);
                gameData.character.health = gameData.character.maxHealth; 
                gameData.character.attack += 2 + Math.floor(gameData.character.level * 0.2);
                gameData.character.defense += 1 + Math.floor(gameData.character.level * 0.1);

                addLog(`Level up! You are now level ${gameData.character.level}. Stats increased!`, "success");
                recalculateCharacterStats(); 
            }
        }


        // --- Map Rendering ---
        function generateMapView() {
            const mapContainer = document.getElementById('mapContainer');
            if (!mapContainer) return;

            const mapScrollContainer = mapContainer.parentElement; 

            mapContainer.innerHTML = ''; 
            mapContainer.style.gridTemplateColumns = `repeat(${gameData.map.width}, minmax(0, 1fr))`;
            mapContainer.className = 'map-grid'; 

            const playerPos = gameData.character.position;

            for (let y = 0; y < gameData.map.height; y++) {
                for (let x = 0; x < gameData.map.width; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'map-cell'; 
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    const key = `${x},${y}`;
                    const isExplored = gameData.map.explored[key];
                    const isPlayerCell = playerPos.x === x && playerPos.y === y;
                    const distanceToPlayer = Math.sqrt(Math.pow(playerPos.x - x, 2) + Math.pow(playerPos.y - y, 2));


                    if (!isExplored && distanceToPlayer > gameData.map.visibleRadius + 2) { 
                        cell.classList.add('bg-stone-900', 'text-stone-700');
                        cell.innerHTML = ' '; 
                    } else if (!isExplored) {
                        cell.classList.add('bg-stone-800', 'text-stone-600');
                        cell.innerHTML = '?'; 
                    } else { 
                        cell.classList.add('bg-amber-800', 'hover:bg-amber-700'); 
                        cell.innerHTML = ''; 

                        const location = gameData.map.locations.find(loc => loc.x === x && loc.y === y);
                        if (location) {
                            if (location.type === 'settlement') { cell.innerHTML = ''; cell.classList.add('bg-green-700', 'text-white'); cell.title = location.name; }
                            else if (location.type === 'ruins') { cell.innerHTML = ''; cell.classList.add('bg-neutral-600', 'text-white'); cell.title = location.name; }
                            else if (location.type === 'oasis') { cell.innerHTML = ''; cell.classList.add('bg-sky-600', 'text-white'); cell.title = location.name; }
                            else if (location.type === 'harkonnen_outpost') { cell.innerHTML = ''; cell.classList.add('bg-red-800', 'text-white'); cell.title = location.name; }
                        }

                        const resourceNode = gameData.map.map_resources.find(r => r.x === x && r.y === y && r.currentAmount > 0);
                        if (resourceNode) {
                            if (resourceNode.type === 'spice') { cell.innerHTML = ''; cell.classList.add('bg-orange-500'); cell.title = `Spice Deposit (${resourceNode.currentAmount})`; }
                            else if (resourceNode.type === 'water') { cell.innerHTML = ''; cell.classList.add('bg-blue-500'); cell.title = `Water Source (${resourceNode.currentAmount})`; }
                            else if (resourceNode.type === 'plasteel_vein') { cell.innerHTML = ''; cell.classList.add('bg-slate-500'); cell.title = `Plasteel (${resourceNode.currentAmount})`;}
                            cell.onclick = () => gatherResourceNode(resourceNode.id);
                        }

                        const mapEnemy = gameData.map.map_enemies.find(e => e.position.x === x && e.position.y === y);
                        if (mapEnemy) {
                             cell.innerHTML = ''; cell.classList.add('bg-red-600', 'text-white'); cell.title = mapEnemy.name;
                             cell.onclick = () => { initiateCombat(mapEnemy, true); };
                        }


                        Object.values(gameData.players).forEach(p => {
                            if (p.position && p.position.x === x && p.position.y === y && p.id !== userId) {
                                cell.innerHTML = ''; cell.classList.add('bg-purple-600', 'text-white'); cell.title = p.name;
                            }
                        });

                        if (isPlayerCell) {
                            cell.innerHTML = ''; 
                            cell.classList.add('bg-yellow-500', 'text-black', 'ring-2', 'ring-white');
                            cell.title = gameData.character.name + " (You)";
                        }
                    }
                    if (!isPlayerCell && isExplored) { 
                         cell.onclick = () => moveCharacter({x:x, y:y});
                    }

                    mapContainer.appendChild(cell);
                }
            }
            const playerMapCell = mapContainer.querySelector(`.map-cell[data-x='${playerPos.x}'][data-y='${playerPos.y}']`);
            if (playerMapCell && mapScrollContainer.scrollTo) {
                 const scrollLeft = playerMapCell.offsetLeft - mapScrollContainer.offsetWidth / 2 + playerMapCell.offsetWidth / 2;
                 const scrollTop = playerMapCell.offsetTop - mapScrollContainer.offsetHeight / 2 + playerMapCell.offsetHeight / 2;
                 mapScrollContainer.scrollTo({ left: scrollLeft, top: scrollTop, behavior: 'smooth' });
            }
        }


        // --- Chat and Multiplayer UI ---
        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            if (!input || !db || !userId) return;
            const messageText = input.value.trim();
            if (messageText) {
                const chatMessage = {
                    senderId: userId,
                    senderName: gameData.character.name,
                    senderHouse: gameData.character.house,
                    message: messageText,
                    timestamp: serverTimestamp(),
                    appId: appId 
                };
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'chat'), chatMessage);
                    input.value = '';
                } catch (error) {
                    console.error("Error sending chat message:", error);
                    addLog("Failed to send message.", "error");
                }
            }
        }
        window.sendChatMessage = sendChatMessage;

        function updateChatDisplay() {
            const chatContainer = document.getElementById('chatMessages');
            if (!chatContainer) return;
            chatContainer.innerHTML = '';
            gameData.chatMessages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'text-sm mb-1 p-1 rounded';
                const senderClass = msg.senderId === userId ? 'text-green-300' : (msg.senderId === 'system' ? 'text-yellow-300' : 'text-amber-300');
                const time = msg.timestamp && msg.timestamp.toDate ? msg.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'sending...';


                let houseColor = 'text-stone-400';
                if (msg.senderHouse === 'Atreides') houseColor = 'text-green-500';
                else if (msg.senderHouse === 'Harkonnen') houseColor = 'text-red-500';
                else if (msg.senderHouse === 'Fremen') houseColor = 'text-sky-500';
                else if (msg.senderHouse === 'Corrino') houseColor = 'text-yellow-500';


                messageDiv.innerHTML = `
                    <span class="text-xs text-stone-500">[${time}]</span>
                    <span class="${senderClass} font-semibold ${houseColor}">${msg.senderName || 'System'}:</span>
                    <span class="text-stone-200 ml-1">${msg.message}</span>
                `;
                if (msg.senderId === userId) messageDiv.classList.add('bg-stone-700');

                chatContainer.appendChild(messageDiv);
            });
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function updateGuildDisplay() { /* Placeholder */ }
        function updatePlayerTracker() {
            const container = document.getElementById('playerTracker');
            if (!container) return;
            container.innerHTML = '<h4 class="text-md font-semibold text-amber-300 mb-2">Nearby Survivors:</h4>';
            let foundPlayers = 0;
            Object.values(gameData.players).forEach(p => {
                if (p.id !== userId && p.isOnline && p.position) { 
                    const dist = Math.sqrt(Math.pow(p.position.x - gameData.character.position.x, 2) + Math.pow(p.position.y - gameData.character.position.y, 2)).toFixed(1);
                    let playerHouseColor = 'text-purple-400'; // Default
                    if (p.house === 'Atreides') playerHouseColor = 'text-green-400';
                    else if (p.house === 'Harkonnen') playerHouseColor = 'text-red-400';
                    else if (p.house === 'Fremen') playerHouseColor = 'text-sky-400';
                    else if (p.house === 'Corrino') playerHouseColor = 'text-yellow-400';

                    container.innerHTML += `
                        <div class="text-xs p-1 rounded bg-stone-700 mb-1">
                            <span class="font-bold ${playerHouseColor}">${p.name}</span> (Lvl ${p.level || 1}) - ${dist} units
                            ${p.pvpEnabled ? '<span class="text-red-400 ml-1">(PvP)</span>' : ''}
                        </div>`;
                    foundPlayers++;
                }
            });
            if (foundPlayers === 0) container.innerHTML += '<p class="text-xs text-stone-400">No other active survivors detected nearby.</p>';
        }
        function updateWorldEventsDisplay() { /* Placeholder */ }

        window.togglePvP = async (isEnabled) => {
            gameData.character.pvpEnabled = isEnabled;
            addLog(`PvP ${isEnabled ? 'Enabled' : 'Disabled'}.`, 'event');
            await updatePlayerDocument({ 
                "character.pvpEnabled": isEnabled,
                "character.lastSeen": serverTimestamp() 
            }); 
            updateUI(); 
        };


        // --- Combat ---
        function checkForEncounters() {
            const pos = gameData.character.position;
            const location = gameData.map.locations.find(loc => loc.x === pos.x && loc.y === pos.y);
            if (location) {
                addLog(`You've reached ${location.name}: ${location.description}`, "event");
                updateQuestProgress('visit_location', 1, location.name);
            }

            const mapEnemy = gameData.map.map_enemies.find(e => e.position.x === pos.x && e.position.y === pos.y && e.currentHealth > 0);
            if (mapEnemy) {
                addLog(`You encountered a ${mapEnemy.name}!`, "combat");
                initiateCombat(mapEnemy, true); 
            }
        }

        function initiateCombat(enemyData, isMapEnemy = false) {
            if (gameData.combat.inCombat) return; 

            gameData.combat.inCombat = true;
            gameData.combat.enemy = JSON.parse(JSON.stringify(enemyData)); 
            if (isMapEnemy) gameData.combat.enemy.isMapEnemy = true; 
            gameData.combat.playerTurn = true;
            gameData.combat.messages = [`Combat started with ${enemyData.name}!`];
            document.getElementById('combatScreen').classList.remove('hidden');
            updateCombatUI();
        }
        
        function updateCombatUI() {
            if (!gameData.combat.inCombat || !gameData.combat.enemy) {
                document.getElementById('combatScreen').classList.add('hidden');
                return;
            }
            document.getElementById('combatPlayerName').textContent = gameData.character.name;
            document.getElementById('combatPlayerHealth').textContent = `${Math.floor(gameData.character.health)} / ${gameData.character.maxHealth}`;
            document.getElementById('combatPlayerHealthBar').style.width = `${(gameData.character.health / gameData.character.maxHealth) * 100}%`;

            document.getElementById('combatEnemyName').textContent = gameData.combat.enemy.name;
            document.getElementById('combatEnemyHealth').textContent = `${Math.floor(gameData.combat.enemy.currentHealth)} / ${gameData.combat.enemy.health}`;
            document.getElementById('combatEnemyHealthBar').style.width = `${(gameData.combat.enemy.currentHealth / gameData.combat.enemy.health) * 100}%`;
            
            const combatLog = document.getElementById('combatLog');
            combatLog.innerHTML = gameData.combat.messages.map(msg => `<p>${msg}</p>`).join('');
            combatLog.scrollTop = combatLog.scrollHeight;

            document.getElementById('combatAttackBtn').disabled = !gameData.combat.playerTurn;
        }

        async function performCombatAction(action) {
            if (!gameData.combat.inCombat || !gameData.combat.playerTurn) return;
            gameData.combat.playerTurn = false; 

            let playerMessage = "";
            let enemyMessage = "";

            if (action === 'attack') {
                const damageDealt = Math.max(1, gameData.character.attack - (gameData.combat.enemy.defense || 0));
                gameData.combat.enemy.currentHealth -= damageDealt;
                playerMessage = `You attack ${gameData.combat.enemy.name} for ${damageDealt} damage.`;
                gameData.combat.messages.push(playerMessage);

                if (gameData.combat.enemy.currentHealth <= 0) {
                    gameData.combat.messages.push(`${gameData.combat.enemy.name} defeated!`);
                    await endCombat(true);
                    return;
                }
            } else if (action === 'flee') {
                if (Math.random() < 0.5) { 
                    gameData.combat.messages.push("You successfully fled!");
                    await endCombat(false, true); 
                    return;
                } else {
                    playerMessage = "You failed to flee!";
                    gameData.combat.messages.push(playerMessage);
                }
            }
            updateCombatUI(); 

            if (gameData.combat.inCombat && gameData.combat.enemy.currentHealth > 0) {
                setTimeout(async () => { 
                    const damageReceived = Math.max(1, (gameData.combat.enemy.attack || 5) - gameData.character.defense);
                    gameData.character.health -= damageReceived;
                    enemyMessage = `${gameData.combat.enemy.name} attacks you for ${damageReceived} damage.`;
                    gameData.combat.messages.push(enemyMessage);

                    if (gameData.character.health <= 0) {
                        gameData.character.health = 0;
                        gameData.combat.messages.push("You have been defeated!");
                        await endCombat(false);
                        return;
                    }
                    gameData.combat.playerTurn = true; 
                    updateCombatUI();
                }, 1000);
            } else if (gameData.combat.inCombat) { 
                 gameData.combat.playerTurn = true; 
            }
        }
        window.performCombatAction = performCombatAction;

        async function endCombat(victory, fled = false) {
            const enemy = gameData.combat.enemy; 
            gameData.combat.inCombat = false;

            if (victory) {
                addLog(`You defeated the ${enemy.name}!`, "success");
                gameData.stats.enemiesDefeated++;
                updateQuestProgress('combat', 1, enemy.id);

                const expGain = Math.floor((enemy.health || 50) / 4) + 10;
                gameData.character.experience += expGain;
                addLog(`Gained ${expGain} XP.`, "success");
                checkLevelUp();

                if (enemy.loot) {
                    if (enemy.loot.solari) {
                        const solariAmount = Math.floor(Math.random() * (enemy.loot.solari[1] - enemy.loot.solari[0] + 1)) + enemy.loot.solari[0];
                        gameData.resources.solari += solariAmount;
                        addLog(`Looted ${solariAmount} Solari.`, "success");
                    }
                    if (enemy.loot.chance) {
                        for (const itemType in enemy.loot.chance) {
                            if (Math.random() < enemy.loot.chance[itemType]) {
                                const amount = (itemType === 'spice' || itemType === 'water' || itemType === 'plasteel') ? Math.floor(Math.random() * 10) + 5 : 1;
                                if (gameData.resources[itemType] !== undefined) {
                                    gameData.resources[itemType] += amount;
                                    addLog(`Looted ${amount} ${itemType}.`, "success");
                                } else { 
                                    const itemDef = gameData.craftingRecipes.find(r => r.output.id === itemType)?.output || { id: itemType, name: itemType, type: 'material', quantity: 1};
                                    const existingInvItem = gameData.inventory.find(i => i.id === itemDef.id);
                                    if(existingInvItem) existingInvItem.quantity += amount;
                                    else gameData.inventory.push({...itemDef, quantity: amount});
                                    addLog(`Found ${amount} ${itemDef.name}!`, "success");
                                }
                            }
                        }
                    }
                }
                
                if (enemy.isMapEnemy && enemy.id && db) {
                    const enemyRef = doc(db, 'artifacts', appId, 'public', 'mapEnemies', enemy.id);
                    try {
                        await updateDoc(enemyRef, { 
                            currentHealth: 0, 
                            respawnTime: serverTimestamp() 
                        }); 
                        gameData.map.map_enemies = gameData.map.map_enemies.filter(me => me.id !== enemy.id);
                        console.log(`Map enemy ${enemy.id} marked for respawn.`);
                    } catch (error) {
                        console.error("Error updating map enemy for respawn:", error);
                    }
                }


            } else if (fled) {
                addLog(`You fled from the ${enemy.name}.`, "action");
            } else { 
                playerDefeated(`Defeated by ${enemy.name}`);
            }
            
            setTimeout(() => { 
                document.getElementById('combatScreen').classList.add('hidden');
                gameData.combat.enemy = null; 
            }, 1500);
            updateUI();
            generateMapView(); 
            debouncedSaveGameData();
        }


        function playerDefeated(reason = "Combat") {
            addLog(`You have been defeated (${reason}). You lose some resources and respawn at a safe location.`, "error");
            gameData.character.health = Math.floor(gameData.character.maxHealth * 0.5); 
            gameData.resources.solari = Math.floor(gameData.resources.solari * 0.75); 
            gameData.resources.spice = Math.floor(gameData.resources.spice * 0.90); 
            const safeSpot = gameData.map.locations.find(l => l.friendly && l.type === 'settlement') || {x: Math.floor(gameData.map.width/2), y: Math.floor(gameData.map.height/2)};
            gameData.character.position = { x: safeSpot.x, y: safeSpot.y };

            if (gameData.combat.inCombat) {
                gameData.combat.inCombat = false;
                document.getElementById('combatScreen').classList.add('hidden');
            }
            updateUI();
            generateMapView();
            debouncedSaveGameData();
        }

        // --- Utility Functions ---
        function addLog(message, type = "info") {
            const logScreen = document.getElementById('logScreen');
            if (!logScreen) return;
            const newLog = document.createElement('p');
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            let typeColor = "text-stone-400";
            if (type === "success") typeColor = "text-green-400";
            else if (type === "error") typeColor = "text-red-400";
            else if (type === "warn") typeColor = "text-yellow-400";
            else if (type === "event") typeColor = "text-purple-400";
            else if (type === "lore") typeColor = "text-sky-400";
            else if (type === "action") typeColor = "text-amber-400";
            else if (type === "combat") typeColor = "text-rose-500";

            newLog.className = `text-sm ${typeColor} mb-1`;
            newLog.innerHTML = `<span class="text-xs text-stone-500">[${time}]</span> ${message}`;
            logScreen.appendChild(newLog);
            if (logScreen.children.length > 150) { logScreen.removeChild(logScreen.firstChild); }
            logScreen.scrollTop = logScreen.scrollHeight;
        }

        function showNarrative(text) { 
            const narrativeScreen = document.getElementById('narrativeScreen');
            const narrativeText = document.getElementById('narrativeText');
            if (narrativeScreen && narrativeText) {
                narrativeText.textContent = text;
                narrativeScreen.classList.remove('hidden');
            }
         }
        window.showNarrative = showNarrative;
        function closeNarrative() { 
            const narrativeScreen = document.getElementById('narrativeScreen');
            if (narrativeScreen) {
                narrativeScreen.classList.add('hidden');
            }
        }
        window.closeNarrative = closeNarrative;


        // --- Game Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            document.getElementById('loadingScreen').classList.remove('hidden');
            await initializeFirebase(); 
            switchTab('game'); 
        });

    </script>
</head>
<body class="bg-stone-900 text-amber-50 antialiased">

    <div id="loadingScreen" class="fixed inset-0 bg-stone-900 bg-opacity-95 z-50 flex flex-col items-center justify-center p-4"> <div class="font-orbitron text-amber-500 text-3xl mb-4">Loading Arrakis...</div>
        <div class="w-16 h-16 border-4 border-amber-400 border-t-transparent rounded-full animate-spin"></div>
        <p class="text-stone-300 mt-4">Connecting to the Spacing Guild...</p>
    </div>


    <div id="characterCreatorScreen" class="fixed inset-0 bg-stone-900 bg-opacity-95 z-50 flex items-center justify-center p-4 hidden">
        <div class="bg-stone-800 p-6 sm:p-8 rounded-xl shadow-2xl max-w-lg w-full">
            <h2 class="text-3xl font-orbitron text-amber-500 mb-6 text-center">Create Your Survivor</h2>
            <div class="space-y-4">
                <div>
                    <label for="characterNameInput" class="block text-sm font-medium text-amber-200 mb-1">Character Name:</label>
                    <input type="text" id="characterNameInput" value="Survivor" class="w-full bg-stone-700 text-white p-2 rounded-md border border-stone-600 focus:ring-amber-500 focus:border-amber-500">
                </div>
                <div>
                    <p class="text-sm font-medium text-amber-200 mb-1">Choose your House Affiliation:</p>
                    <div class="grid grid-cols-2 gap-3">
                        <div><input type="radio" name="house" value="Atreides" id="houseAtreides" class="sr-only peer" checked><label for="houseAtreides" class="block bg-stone-700 p-3 rounded-md text-center cursor-pointer peer-checked:bg-green-600 peer-checked:text-white hover:bg-stone-600 transition-all">Atreides<br><span class="text-xs">+30 Max Health, +10 Food</span></label></div>
                        <div><input type="radio" name="house" value="Harkonnen" id="houseHarkonnen" class="sr-only peer"><label for="houseHarkonnen" class="block bg-stone-700 p-3 rounded-md text-center cursor-pointer peer-checked:bg-red-600 peer-checked:text-white hover:bg-stone-600 transition-all">Harkonnen<br><span class="text-xs">+150 Solari, +3 Attack</span></label></div>
                        <div><input type="radio" name="house" value="Corrino" id="houseCorrino" class="sr-only peer"><label for="houseCorrino" class="block bg-stone-700 p-3 rounded-md text-center cursor-pointer peer-checked:bg-yellow-500 peer-checked:text-black hover:bg-stone-600 transition-all">Corrino<br><span class="text-xs">+15 Plasteel, +75 Solari</span></label></div>
                        <div><input type="radio" name="house" value="Fremen" id="houseFremen" class="sr-only peer"><label for="houseFremen" class="block bg-stone-700 p-3 rounded-md text-center cursor-pointer peer-checked:bg-sky-600 peer-checked:text-white hover:bg-stone-600 transition-all">Fremen<br><span class="text-xs">+30 Water, +3 Defense</span></label></div>
                    </div>
                </div>
                <div>
                    <p class="text-sm font-medium text-amber-200 mb-1">Choose your Background:</p>
                     <div class="grid grid-cols-2 gap-3">
                        <div><input type="radio" name="background" value="Scout" id="bgScout" class="sr-only peer" checked><label for="bgScout" class="block bg-stone-700 p-3 rounded-md text-center cursor-pointer peer-checked:bg-teal-600 peer-checked:text-white hover:bg-stone-600 transition-all">Scout<br><span class="text-xs">+15 Water, +1 Vision</span></label></div>
                        <div><input type="radio" name="background" value="Technician" id="bgTechnician" class="sr-only peer"><label for="bgTechnician" class="block bg-stone-700 p-3 rounded-md text-center cursor-pointer peer-checked:bg-indigo-600 peer-checked:text-white hover:bg-stone-600 transition-all">Technician<br><span class="text-xs">+10 Plasteel, Tools</span></label></div>
                        <div><input type="radio" name="background" value="Warrior" id="bgWarrior" class="sr-only peer"><label for="bgWarrior" class="block bg-stone-700 p-3 rounded-md text-center cursor-pointer peer-checked:bg-rose-600 peer-checked:text-white hover:bg-stone-600 transition-all">Warrior<br><span class="text-xs">+5 Atk, +3 Def, +20 HP</span></label></div>
                        <div><input type="radio" name="background" value="Merchant" id="bgMerchant" class="sr-only peer"><label for="bgMerchant" class="block bg-stone-700 p-3 rounded-md text-center cursor-pointer peer-checked:bg-lime-600 peer-checked:text-white hover:bg-stone-600 transition-all">Merchant<br><span class="text-xs">+200 Solari</span></label></div>
                    </div>
                </div>
                <button onclick="finalizeCharacterCreation()" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-colors mt-6">Begin Your Journey on Arrakis</button>
            </div>
        </div>
    </div>

    <div id="mainGameScreen" class="container mx-auto p-2 sm:p-4 max-w-full xl:max-w-8xl hidden">
        <div id="narrativeScreen" class="fixed inset-0 bg-stone-900 bg-opacity-95 z-50 flex items-center justify-center p-4 hidden">
            <div class="bg-stone-800 p-6 sm:p-8 rounded-xl shadow-2xl max-w-lg w-full">
                <h2 class="text-2xl font-orbitron text-amber-500 mb-4 text-center">A Message from Arrakis</h2>
                <p id="narrativeText" class="text-stone-300 mb-4"></p>
                <button onclick="closeNarrative()" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-colors">Continue</button>
            </div>
        </div>

        <header class="bg-stone-800 p-4 rounded-lg shadow-xl mb-4">
            <div class="flex flex-col sm:flex-row justify-between items-center">
                <h1 class="text-3xl sm:text-4xl font-orbitron text-amber-500 mb-2 sm:mb-0">Arrakis Tycoon MMO</h1>
                <div class="text-xs text-stone-400">User ID: <span id="userIdDisplay">Not Connected</span></div>
            </div>
             <nav class="mt-4 flex flex-wrap justify-center sm:justify-start space-x-1 sm:space-x-2 border-b border-stone-700 pb-2">
                <button onclick="switchTab('game')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Game</button>
                <button onclick="switchTab('character')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Character</button>
                <button onclick="switchTab('upgrades')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Upgrades</button>
                <button onclick="switchTab('buildings')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Buildings</button>
                <button onclick="switchTab('units')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Units</button>
                <button onclick="switchTab('map')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Map</button>
                <button onclick="switchTab('quests')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Quests</button>
                <button onclick="switchTab('crafting')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Crafting</button>
                <button onclick="switchTab('inventory')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Inventory</button>
                <button onclick="switchTab('multiplayer')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Multiplayer</button>
                <button onclick="switchTab('lore')" class="tab-button py-2 px-2 sm:px-3 rounded-t-md text-xs sm:text-sm font-medium border-b-2 border-transparent">Lore</button>
            </nav>
        </header>

        <div id="gameScreen" class="main-tab-content bg-stone-800 p-4 rounded-lg shadow-xl">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="md:col-span-1 space-y-4">
                    <div class="bg-stone-700 p-4 rounded-lg shadow">
                        <h3 class="text-xl font-semibold text-amber-400 mb-2">Resources</h3>
                        <p> Spice: <span id="spiceDisplay" class="font-bold text-amber-300">0</span></p>
                        <p> Water: <span id="waterDisplay" class="font-bold text-sky-300">0</span></p>
                        <p> Solari: <span id="solariDisplay" class="font-bold text-yellow-300">0</span></p>
                        <p> Plasteel: <span id="plasteelDisplay" class="font-bold text-slate-300">0</span></p>
                        <p> Food: <span id="foodDisplay" class="font-bold text-orange-300">0</span></p>
                        <div class="mt-2">
                            <p> Health: <span id="healthDisplayMain" class="font-bold text-green-300"></span></p>
                            <div class="w-full progress-bar-bg rounded-full h-2.5 mt-1">
                                <div id="healthBarFillMain" class="progress-bar-fill h-2.5 rounded-full"></div>
                            </div>
                        </div>
                    </div>
                    <div class="bg-stone-700 p-4 rounded-lg shadow">
                        <h3 class="text-xl font-semibold text-amber-400 mb-2">Manual Actions</h3>
                        <button onclick="manualHarvestSpice()" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-2 px-4 rounded-md mb-2 transition-colors"> Harvest Spice</button>
                        <p class="text-xs text-stone-300 text-center">Click to gather spice manually</p>
                    </div>
                </div>
                <div class="md:col-span-2 bg-stone-700 p-4 rounded-lg shadow">
                    <h3 class="text-xl font-semibold text-amber-400 mb-2"> Event Log</h3>
                    <div id="logScreen" class="h-64 sm:h-96 overflow-y-auto bg-stone-800 p-3 rounded-md border border-stone-600 text-sm">
                        <p class="text-stone-400 text-center">Welcome to Arrakis. Your journey begins...</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="characterScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Character Status</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="bg-stone-700 p-4 rounded-lg shadow space-y-2">
                    <p>Name: <span id="characterNameDisplay" class="font-semibold text-amber-300"></span></p>
                    <p>House: <span id="characterHouseDisplay" class="font-semibold text-amber-300"></span></p>
                    <p>Background: <span id="characterBackgroundDisplay" class="font-semibold text-amber-300"></span></p>
                    <p>Level: <span id="characterLevelDisplay" class="font-semibold text-amber-300"></span> | Exp: <span id="characterExpDisplay" class="font-semibold text-amber-300"></span></p>
                    <p>Attack: <span id="characterAttackDisplay" class="font-semibold text-amber-300"></span> | Defense: <span id="characterDefenseDisplay" class="font-semibold text-amber-300"></span></p>
                    <div>
                        <p>Health: <span id="healthDisplay" class="font-semibold text-green-400"></span></p>
                        <div class="w-full progress-bar-bg rounded-full h-4 mt-1">
                            <div id="healthBarFill" class="progress-bar-fill h-4 rounded-full"></div>
                        </div>
                    </div>
                    <div class="mt-2">
                        <label for="pvpToggle" class="flex items-center cursor-pointer">
                            <span class="mr-2 text-sm text-stone-300">Enable PvP:</span>
                            <div class="relative">
                                <input type="checkbox" id="pvpToggle" class="sr-only" onchange="togglePvP(this.checked)">
                                <div class="block bg-stone-600 w-10 h-6 rounded-full peer-checked:bg-red-500 transition-colors"></div>
                                <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-transform peer-checked:translate-x-full"></div>
                            </div>
                        </label>
                    </div>
                </div>
                <div id="equippedItemsDisplay" class="bg-stone-700 p-4 rounded-lg shadow space-y-1">
                    <h3 class="text-lg font-semibold text-amber-400 mb-2">Equipped Gear</h3>
                    </div>
            </div>
        </div>


        <div id="upgradesScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Harvester Upgrades</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <div class="bg-stone-700 p-4 rounded-lg shadow">
                    <h3 class="text-lg font-semibold text-amber-400 mb-2"> Manual Spice Harvesting</h3>
                    <p class="text-sm text-stone-300">Level: <span id="manualSpiceLevel">1</span></p>
                    <p class="text-sm text-stone-300 mb-2">Upgrade Cost: <span id="manualSpiceUpgradeCost">20</span> Solari</p>
                    <button onclick="upgradeManualSpiceHarvester()" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-3 rounded-md text-sm transition-colors">Upgrade</button>
                </div>
                <div class="bg-stone-700 p-4 rounded-lg shadow">
                    <h3 class="text-lg font-semibold text-amber-400 mb-2"> Spice Auto-Harvesters</h3>
                    <p class="text-sm text-stone-300">Count: <span id="autoSpiceCount">0</span> | Efficiency Lvl: <span id="autoSpiceLevel">0</span></p>
                    <p class="text-sm text-stone-300 mb-1">Buy New Cost: <span id="autoSpiceCost">100</span> Solari</p>
                    <button onclick="buyAutoHarvester('spice')" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-md text-sm mb-2 transition-colors">Buy Harvester</button>
                    <p class="text-sm text-stone-300 mb-1">Upgrade Eff. Cost: <span id="autoSpiceUpgradeEffCost">N/A</span> Solari</p>
                    <button onclick="upgradeAutoHarvester('spice')" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-3 rounded-md text-sm transition-colors">Upgrade Efficiency</button>
                </div>
                <div class="bg-stone-700 p-4 rounded-lg shadow">
                    <h3 class="text-lg font-semibold text-amber-400 mb-2"> Water Auto-Collectors</h3>
                    <p class="text-sm text-stone-300">Count: <span id="autoWaterCount">0</span> | Efficiency Lvl: <span id="autoWaterLevel">0</span></p>
                    <p class="text-sm text-stone-300 mb-1">Buy New Cost: <span id="autoWaterCost">150</span> Solari</p>
                    <button onclick="buyAutoHarvester('water')" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-md text-sm mb-2 transition-colors">Buy Collector</button>
                    <p class="text-sm text-stone-300 mb-1">Upgrade Eff. Cost: <span id="autoWaterUpgradeEffCost">N/A</span> Solari</p>
                    <button onclick="upgradeAutoHarvester('water')" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-3 rounded-md text-sm transition-colors">Upgrade Efficiency</button>
                </div>
            </div>
        </div>

        <div id="buildingsScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Buildings</h2>
            <div id="buildingsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                </div>
        </div>

        <div id="unitsScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Units</h2>
            <div id="unitsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                </div>
        </div>

        <div id="mapScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <div class="flex flex-col xl:flex-row gap-4">
                <div class="flex-grow map-scroll-container bg-stone-900 p-1 rounded-md shadow-inner overflow-auto" style="max-height: 70vh;">
                    <div id="mapContainer" class="inline-block">
                        </div>
                </div>
                <div class="xl:w-1/4 space-y-3">
                    <h3 class="text-xl font-orbitron text-amber-500">Navigation</h3>
                    <div class="grid grid-cols-3 gap-2">
                        <div></div>
                        <button onclick="moveCharacter('north')" class="bg-stone-600 hover:bg-stone-500 text-white py-2 px-3 rounded-md transition-colors">North </button>
                        <div></div>
                        <button onclick="moveCharacter('west')" class="bg-stone-600 hover:bg-stone-500 text-white py-2 px-3 rounded-md transition-colors">West </button>
                        <div class="flex items-center justify-center text-stone-400">(<span id="mapPlayerX">0</span>,<span id="mapPlayerY">0</span>)</div>
                        <button onclick="moveCharacter('east')" class="bg-stone-600 hover:bg-stone-500 text-white py-2 px-3 rounded-md transition-colors">East </button>
                        <div></div>
                        <button onclick="moveCharacter('south')" class="bg-stone-600 hover:bg-stone-500 text-white py-2 px-3 rounded-md transition-colors">South </button>
                        <div></div>
                    </div>
                    <div id="mapInfoPanel" class="bg-stone-700 p-3 rounded-md text-sm">
                        <h4 class="font-semibold text-amber-300">Cell Info:</h4>
                        <p id="mapCellDetails">Click on the map to move or see details.</p>
                    </div>
                </div>
            </div>
        </div>


        <div id="questsScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Quests Log</h2>
            <div id="questsList" class="space-y-3">
                </div>
        </div>

        <div id="craftingScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Crafting Station</h2>
            <div id="craftingRecipesList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                </div>
        </div>

        <div id="inventoryScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Inventory</h2>
            <div id="inventoryList" class="space-y-3">
                </div>
        </div>

        <div id="multiplayerScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Multiplayer Hub</h2>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                <div class="lg:col-span-2 space-y-4">
                    <div class="bg-stone-700 p-4 rounded-lg shadow">
                        <h3 class="text-lg font-semibold text-amber-400 mb-2"> Global Chat</h3>
                        <div id="chatMessages" class="h-64 overflow-y-auto bg-stone-800 p-3 rounded-md border border-stone-600 text-sm mb-2">
                            </div>
                        <div class="flex gap-2">
                            <input type="text" id="chatInput" placeholder="Type your message..." class="flex-1 bg-stone-600 text-white p-2 rounded text-sm border border-stone-500 focus:ring-amber-500 focus:border-amber-500" maxlength="120">
                            <button onclick="sendChatMessage()" class="bg-amber-600 hover:bg-amber-700 text-white px-4 py-2 rounded text-sm font-semibold transition-colors">Send</button>
                        </div>
                    </div>
                    <div id="guildInfo" class="bg-stone-700 p-4 rounded-lg shadow">
                        <h3 class="text-lg font-semibold text-amber-400 mb-2"> Guild (Coming Soon)</h3>
                        <p class="text-sm text-stone-400">Form alliances and conquer Arrakis together!</p>
                    </div>
                </div>
                <div class="space-y-4">
                    <div class="bg-stone-700 p-4 rounded-lg shadow">
                        <div id="playerTracker" class="space-y-2 max-h-60 overflow-y-auto">
                             </div>
                    </div>
                    <div class="bg-stone-700 p-4 rounded-lg shadow">
                        <h3 class="text-lg font-semibold text-amber-400 mb-2"> World Events (Coming Soon)</h3>
                        <div id="worldEventsDisplay" class="space-y-2 text-sm text-stone-300">
                            <p>Dynamic events will shape the world of Arrakis.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <div id="loreScreen" class="main-tab-content hidden bg-stone-800 p-4 rounded-lg shadow-xl">
            <h2 class="text-2xl font-orbitron text-amber-500 mb-4"> Whispers of Arrakis (Lore)</h2>
            <div id="loreContent" class="prose prose-sm sm:prose prose-invert max-w-none bg-stone-700 p-4 rounded-md shadow h-96 overflow-y-auto">
                <h3 class="text-amber-400"> The Spice Melange</h3>
                <p>Melange, colloquially known as "the spice," is a psychoactive chemical substance found only on the desert planet Arrakis. It is the most valuable and rarest commodity in the Imperium.</p>
                <p>The spice extends life, enhances sensory perception and awareness, and for a select few, unlocks presciencethe ability to see limited pathways of the future. This prescience is essential for Navigators of the Spacing Guild, who use it to guide starships through foldspace, making interstellar travel possible.</p>

                <h3 class="text-amber-400"> Shai-Hulud (The Sandworms)</h3>
                <p>The great sandworms of Arrakis, also known by the Fremen as Shai-Hulud or "Old Man of the Desert," are colossal creatures that dominate the deep desert. They are inextricably linked to the spice cycle, as their lifecycle produces the precious melange.</p>
                <p>These massive beings can grow to lengths of over 400 meters and are attracted to rhythmic vibrations in the sand. The Fremen have learned to ride these magnificent creatures, using maker hooks and thumpers to control their movement.</p>

                <h3 class="text-amber-400"> The Fremen</h3>
                <p>The Fremen are the native human inhabitants of Arrakis, descendants of the Zensunni wanderers who fled religious persecution. They have adapted perfectly to the harsh desert environment, developing a culture centered around water conservation and survival.</p>
                <p>Their blue-within-blue eyes, caused by constant exposure to spice, mark them as true children of the desert. They possess unmatched fighting skills and an intimate knowledge of the desert that makes them formidable allies or enemies.</p>

                <h3 class="text-amber-400"> The Stillsuit</h3>
                <p>A stillsuit is a full-body suit worn in the open desert of Arrakis that is designed to preserve the body's moisture. The suit recycles all bodily fluids, including urine and perspiration, filtering and purifying them into drinkable water.</p>
                <p>A properly maintained stillsuit can reduce water loss to as little as a thimbleful per day, making survival in the deep desert possible. The technology represents the pinnacle of Fremen engineering and desert adaptation.</p>

                <h3 class="text-amber-400"> The Great Houses</h3>
                <p><strong>House Atreides:</strong> Known for their honor, loyalty, and just rule. Led by Duke Leto Atreides, they inspire fierce loyalty among their followers and are respected throughout the Imperium.</p>
                <p><strong>House Harkonnen:</strong> The bitter enemies of House Atreides, known for their cruelty, cunning, and ruthless pursuit of power. They previously controlled Arrakis and its spice production.</p>
                <p><strong>House Corrino:</strong> The Imperial House, rulers of the known universe for over 10,000 years. Emperor Shaddam IV sits upon the Golden Lion Throne, commanding the fearsome Sardaukar legions.</p>
            </div>
        </div>

        <div id="combatScreen" class="fixed inset-0 bg-stone-900 bg-opacity-90 z-50 flex items-center justify-center p-4 hidden">
            <div class="bg-stone-800 p-6 rounded-xl shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-orbitron text-amber-500 mb-4 text-center"> Combat Encounter!</h2>
                <div class="flex justify-between mb-4">
                    <div class="text-center">
                        <h3 id="combatPlayerName" class="text-lg font-semibold text-green-400">You</h3>
                        <p class="text-sm">Health: <span id="combatPlayerHealth" class="font-bold"></span></p>
                        <div class="w-32 h-3 progress-bar-bg rounded-full mx-auto mt-1"><div id="combatPlayerHealthBar" class="progress-bar-fill h-3 rounded-full"></div></div>
                    </div>
                    <div class="text-center">
                        <h3 id="combatEnemyName" class="text-lg font-semibold text-red-400">Enemy</h3>
                        <p class="text-sm">Health: <span id="combatEnemyHealth" class="font-bold"></span></p>
                        <div class="w-32 h-3 progress-bar-bg rounded-full mx-auto mt-1"><div id="combatEnemyHealthBar" class="progress-bar-fill h-3 rounded-full bg-red-500"></div></div>
                    </div>
                </div>
                <div id="combatLog" class="h-24 overflow-y-auto bg-stone-700 p-2 rounded-md text-xs mb-3 border border-stone-600"></div>
                <div class="flex justify-around">
                    <button id="combatAttackBtn" onclick="performCombatAction('attack')" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Attack</button>
                    <button id="combatFleeBtn" onclick="performCombatAction('flee')" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Flee</button>
                </div>
            </div>
        </div>


        <footer class="text-center mt-8 py-4 border-t border-stone-700">
            <p class="text-xs text-stone-400">Arrakis Tycoon MMO v3.0 - The Spice Must Flow</p>
            <p class="text-xs text-stone-500 mt-1">Dune IP  Herbert Properties LLC. Fan project for entertainment only.</p>
        </footer>
    </div>

</body>
</html>

