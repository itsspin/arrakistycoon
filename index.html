<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrakis Tycoon - Dune MMO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #1c1917; }
        h1, h2, h3, h4, .font-orbitron { font-family: 'Orbitron', sans-serif; }
        .tab-button { transition: all 0.2s ease-in-out; }
        .tab-button.active { border-bottom-color: #f59e0b; color: #f59e0b; }
        .progress-bar-bg { background-color: #57534e; }
        .progress-bar-fill { background-color: #f59e0b; transition: width 0.3s ease; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #44403c; border-radius: 4px;}
        ::-webkit-scrollbar-thumb { background: #a8a29e; border-radius: 4px;}
        ::-webkit-scrollbar-thumb:hover { background: #d6d3d1; }
        .map-grid { display: grid; gap: 1px; background-color: #292524; border: 1px solid #44403c; }
        .map-cell { 
            position: relative;
            transition: all 0.1s;
            border: 1px solid transparent;
        }
        .map-cell:hover {
            transform: scale(1.1);
            z-index: 10;
            border-color: #ffffff;
        }
        .map-cell[data-coords]::after {
            content: attr(data-coords);
            position: absolute;
            bottom: 0;
            right: 0;
            font-size: 0.5rem;
            color: rgba(255,255,255,0.4);
            pointer-events: none;
        }
        .map-scroll-container {
            max-width: 100%;
            overflow: auto;
            scrollbar-width: thin;
            scrollbar-color: #78716c #292524;
        }
        .map-scroll-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .map-scroll-container::-webkit-scrollbar-track {
            background: #292524;
        }
        .map-scroll-container::-webkit-scrollbar-thumb {
            background-color: #78716c;
            border-radius: 4px;
        }
        #minimapContainer {
            cursor: pointer;
            box-shadow: 0 0 0 1px rgba(255,255,255,0.1);
            z-index: 20;
        }
        #minimapContainer::before {
            content: "Minimap";
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 8px;
            color: rgba(255,255,255,0.7);
            z-index: 1;
        }
        .player-indicator { animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body class="bg-stone-900 text-amber-50 antialiased">

    <script type="module">
        // ===== CORE GAME STATE MANAGEMENT =====
        class GameState {
            constructor() {
                this.initialized = false;
                this.loading = true;
                this.currentTab = 'game';
                this.lastUpdate = Date.now();
                this.gameSpeed = 1000; // ms per tick
                
                // Player data
                this.player = {
                    id: null,
                    name: 'Survivor',
                    house: null,
                    background: null,
                    level: 1,
                    experience: 0,
                    experienceToNext: 100,
                    health: 100,
                    maxHealth: 100,
                    attack: 10,
                    defense: 5,
                    position: { x: 25, y: 25 },
                    equipment: { weapon: null, armor: null, accessory: null },
                    online: false
                };
                
                // Resources
                this.resources = {
                    spice: 0,
                    water: 50,
                    solari: 200,
                    plasteel: 0,
                    food: 20
                };
                
                // Production systems
                this.production = {
                    manual: {
                        spice: { level: 1, efficiency: 1 }
                    },
                    auto: {
                        spice: { count: 0, level: 0, efficiency: 1 },
                        water: { count: 0, level: 0, efficiency: 1 }
                    }
                };
                
                // Upgrade costs
                this.upgrades = {
                    manualSpice: 20,
                    autoSpice: 100,
                    autoWater: 150
                };
                
                // Inventory and crafting
                this.inventory = [];
                this.buildings = [];
                this.units = [];
                
                // Map and exploration
                this.map = {
                    width: 50,
                    height: 50,
                    explored: new Set(),
                    visibleRadius: 3,
                    resources: new Map(),
                    enemies: new Map(),
                    locations: new Map()
                };
                
                // Combat system
                this.combat = {
                    active: false,
                    enemy: null,
                    playerTurn: true,
                    messages: []
                };
                
                // Quest system
                this.quests = new Map();
                
                // Statistics
                this.stats = {
                    spiceHarvested: 0,
                    solariEarned: 0,
                    enemiesDefeated: 0,
                    areasExplored: 0,
                    questsCompleted: 0
                };
                
                this.initializeStaticData();
            }
            
            initializeStaticData() {
                // Initialize static locations
                this.map.locations.set('25,25', {
                    type: 'settlement',
                    name: 'Starting Outpost',
                    description: 'Your humble beginning on Arrakis',
                    friendly: true
                });
                
                this.map.locations.set('40,40', {
                    type: 'settlement',
                    name: 'Arrakeen',
                    description: 'The planetary capital',
                    friendly: true,
                    market: true
                });
                
                this.map.locations.set('10,10', {
                    type: 'ruins',
                    name: 'Ancient Outpost',
                    description: 'Ruins holding secrets',
                    loot: true
                });
                
                // Initialize starting quest
                this.quests.set('q1', {
                    id: 'q1',
                    title: 'First Steps on Arrakis',
                    description: 'Learn the basics of survival',
                    objectives: [
                        { id: 'harvest_spice', description: 'Harvest 50 Spice', target: 'spice', amount: 50, progress: 0, completed: false },
                        { id: 'explore_areas', description: 'Explore 5 areas', target: 'explore', amount: 5, progress: 0, completed: false }
                    ],
                    rewards: { solari: 100, experience: 50 },
                    active: true,
                    completed: false
                });
            }
            
            // Save/Load functionality
            save() {
                const saveData = {
                    player: this.player,
                    resources: this.resources,
                    production: this.production,
                    upgrades: this.upgrades,
                    inventory: this.inventory,
                    buildings: this.buildings,
                    units: this.units,
                    map: {
                        explored: Array.from(this.map.explored),
                        resources: Array.from(this.map.resources.entries()),
                        enemies: Array.from(this.map.enemies.entries())
                    },
                    quests: Array.from(this.quests.entries()),
                    stats: this.stats,
                    timestamp: Date.now()
                };
                
                localStorage.setItem('arrakisTycoonSave', JSON.stringify(saveData));
                this.log('Game saved successfully', 'success');
            }
            
            load() {
                const saveData = localStorage.getItem('arrakisTycoonSave');
                if (!saveData) return false;
                
                try {
                    const data = JSON.parse(saveData);
                    
                    // Restore data
                    Object.assign(this.player, data.player);
                    Object.assign(this.resources, data.resources);
                    Object.assign(this.production, data.production);
                    Object.assign(this.upgrades, data.upgrades);
                    this.inventory = data.inventory || [];
                    this.buildings = data.buildings || [];
                    this.units = data.units || [];
                    
                    // Restore map data
                    this.map.explored = new Set(data.map.explored || []);
                    this.map.resources = new Map(data.map.resources || []);
                    this.map.enemies = new Map(data.map.enemies || []);
                    
                    // Restore quests
                    this.quests = new Map(data.quests || []);
                    
                    Object.assign(this.stats, data.stats);
                    
                    this.log('Game loaded successfully', 'success');
                    return true;
                } catch (error) {
                    console.error('Failed to load save data:', error);
                    return false;
                }
            }
            
            // Logging system
            log(message, type = 'info') {
                const logContainer = document.getElementById('gameLog');
                if (!logContainer) return;
                
                const logEntry = document.createElement('div');
                logEntry.className = `text-sm mb-1 ${this.getLogColor(type)}`;
                
                const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                logEntry.innerHTML = `<span class="text-xs text-stone-500">[${timestamp}]</span> ${message}`;
                
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Keep only last 100 messages
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }
            
            getLogColor(type) {
                const colors = {
                    info: 'text-stone-300',
                    success: 'text-green-400',
                    error: 'text-red-400',
                    warning: 'text-yellow-400',
                    event: 'text-purple-400',
                    combat: 'text-rose-400',
                    action: 'text-amber-400'
                };
                return colors[type] || colors.info;
            }
        }

        // ===== RESOURCE MANAGEMENT SYSTEM =====
        class ResourceManager {
            constructor(gameState) {
                this.gameState = gameState;
            }
            
            // Manual resource gathering
            harvestSpice() {
                const amount = this.gameState.production.manual.spice.level * this.gameState.production.manual.spice.efficiency;
                this.gameState.resources.spice += amount;
                this.gameState.stats.spiceHarvested += amount;
                
                this.gameState.log(`Harvested ${amount} Spice manually`, 'action');
                this.updateQuestProgress('spice', amount);
                
                return amount;
            }
            
            // Automatic resource production (called each game tick)
            processAutoProduction() {
                // Spice auto-harvesters
                const spiceProduction = this.gameState.production.auto.spice;
                if (spiceProduction.count > 0) {
                    const amount = spiceProduction.count * spiceProduction.level * spiceProduction.efficiency;
                    this.gameState.resources.spice += amount;
                    this.gameState.stats.spiceHarvested += amount;
                }
                
                // Water auto-collectors
                const waterProduction = this.gameState.production.auto.water;
                if (waterProduction.count > 0) {
                    const amount = waterProduction.count * waterProduction.level * waterProduction.efficiency;
                    this.gameState.resources.water += amount;
                }
                
                // Building production
                this.gameState.buildings.forEach(building => {
                    if (building.level > 0 && building.production) {
                        Object.entries(building.production).forEach(([resource, amount]) => {
                            this.gameState.resources[resource] += amount * building.level;
                        });
                    }
                });
                
                // Unit upkeep
                this.gameState.units.forEach(unit => {
                    if (unit.count > 0 && unit.upkeep) {
                        Object.entries(unit.upkeep).forEach(([resource, amount]) => {
                            this.gameState.resources[resource] -= amount * unit.count;
                            if (this.gameState.resources[resource] < 0) {
                                this.gameState.resources[resource] = 0;
                            }
                        });
                    }
                });
            }
            
            // Resource spending
            canAfford(costs) {
                return Object.entries(costs).every(([resource, amount]) => 
                    this.gameState.resources[resource] >= amount
                );
            }
            
            spend(costs) {
                if (!this.canAfford(costs)) return false;
                
                Object.entries(costs).forEach(([resource, amount]) => {
                    this.gameState.resources[resource] -= amount;
                });
                
                return true;
            }
            
            // Upgrade systems
            upgradeManualSpice() {
                const cost = this.gameState.upgrades.manualSpice;
                if (!this.canAfford({ solari: cost })) {
                    this.gameState.log('Not enough Solari for upgrade', 'error');
                    return false;
                }
                
                this.spend({ solari: cost });
                this.gameState.production.manual.spice.level++;
                this.gameState.upgrades.manualSpice = Math.floor(cost * 1.5);
                
                this.gameState.log('Manual spice harvesting upgraded!', 'success');
                return true;
            }
            
            buyAutoHarvester(type) {
                const cost = this.gameState.upgrades[`auto${type.charAt(0).toUpperCase() + type.slice(1)}`];
                if (!this.canAfford({ solari: cost })) {
                    this.gameState.log('Not enough Solari for auto-harvester', 'error');
                    return false;
                }
                
                this.spend({ solari: cost });
                this.gameState.production.auto[type].count++;
                this.gameState.upgrades[`auto${type.charAt(0).toUpperCase() + type.slice(1)}`] = Math.floor(cost * 1.25);
                
                this.gameState.log(`Purchased ${type} auto-harvester!`, 'success');
                return true;
            }
            
            upgradeAutoHarvester(type) {
                const production = this.gameState.production.auto[type];
                if (production.count === 0) {
                    this.gameState.log(`No ${type} harvesters to upgrade`, 'warning');
                    return false;
                }
                
                const cost = Math.floor(100 * Math.pow(1.8, production.level) * production.count);
                if (!this.canAfford({ solari: cost })) {
                    this.gameState.log('Not enough Solari for upgrade', 'error');
                    return false;
                }
                
                this.spend({ solari: cost });
                production.level++;
                production.efficiency = 1 + (production.level * 0.5);
                
                this.gameState.log(`${type} auto-harvester efficiency upgraded!`, 'success');
                return true;
            }
            
            updateQuestProgress(type, amount) {
                this.gameState.quests.forEach(quest => {
                    if (!quest.active || quest.completed) return;
                    
                    quest.objectives.forEach(objective => {
                        if (objective.completed || objective.target !== type) return;
                        
                        objective.progress += amount;
                        if (objective.progress >= objective.amount) {
                            objective.completed = true;
                            this.gameState.log(`Objective completed: ${objective.description}`, 'event');
                            this.checkQuestCompletion(quest);
                        }
                    });
                });
            }
            
            checkQuestCompletion(quest) {
                if (quest.objectives.every(obj => obj.completed)) {
                    quest.completed = true;
                    quest.active = false;
                    
                    // Apply rewards
                    Object.entries(quest.rewards).forEach(([resource, amount]) => {
                        if (resource === 'experience') {
                            this.gameState.player.experience += amount;
                            this.checkLevelUp();
                        } else {
                            this.gameState.resources[resource] += amount;
                        }
                    });
                    
                    this.gameState.stats.questsCompleted++;
                    this.gameState.log(`Quest completed: ${quest.title}!`, 'success');
                }
            }
            
            checkLevelUp() {
                while (this.gameState.player.experience >= this.gameState.player.experienceToNext) {
                    this.gameState.player.level++;
                    this.gameState.player.experience -= this.gameState.player.experienceToNext;
                    this.gameState.player.experienceToNext = Math.floor(this.gameState.player.experienceToNext * 1.5);
                    
                    // Increase stats
                    this.gameState.player.maxHealth += 15;
                    this.gameState.player.health = this.gameState.player.maxHealth;
                    this.gameState.player.attack += 2;
                    this.gameState.player.defense += 1;
                    
                    this.gameState.log(`Level up! You are now level ${this.gameState.player.level}`, 'success');
                }
            }
        }

        // ===== MOVEMENT AND EXPLORATION SYSTEM =====
        class MovementSystem {
            constructor(gameState) {
                this.gameState = gameState;
                this.movementCost = 1; // Water cost per move
            }
            
            canMoveTo(x, y) {
                // Check bounds
                if (x < 0 || x >= this.gameState.map.width || y < 0 || y >= this.gameState.map.height) {
                    return { valid: false, reason: 'Out of bounds' };
                }
                
                // Check water cost
                if (this.gameState.resources.water < this.movementCost) {
                    return { valid: false, reason: 'Not enough water' };
                }
                
                // Check if in combat
                if (this.gameState.combat.active) {
                    return { valid: false, reason: 'Cannot move during combat' };
                }
                
                return { valid: true };
            }
            
            movePlayer(x, y) {
                const currentPos = this.gameState.player.position;
                
                // Validate movement (only adjacent cells or direct coordinate input)
                const dx = Math.abs(x - currentPos.x);
                const dy = Math.abs(y - currentPos.y);
                
                if (dx > 1 || dy > 1 || (dx === 0 && dy === 0)) {
                    this.gameState.log('Can only move to adjacent cells', 'warning');
                    return false;
                }
                
                const moveCheck = this.canMoveTo(x, y);
                if (!moveCheck.valid) {
                    this.gameState.log(moveCheck.reason, 'error');
                    return false;
                }
                
                // Execute movement
                this.gameState.resources.water -= this.movementCost;
                this.gameState.player.position = { x, y };
                
                // Explore new area
                this.exploreArea(x, y);
                
                // Check for encounters
                this.checkEncounters(x, y);
                
                this.gameState.log(`Moved to (${x}, ${y})`, 'action');
                return true;
            }
            
            moveDirection(direction) {
                const pos = this.gameState.player.position;
                let newX = pos.x;
                let newY = pos.y;
                
                switch (direction) {
                    case 'north': newY = pos.y - 1; break;
                    case 'south': newY = pos.y + 1; break;
                    case 'west': newX = pos.x - 1; break;
                    case 'east': newX = pos.x + 1; break;
                    default: return false;
                }
                
                return this.movePlayer(newX, newY);
            }
            
            exploreArea(x, y) {
                const key = `${x},${y}`;
                
                // Mark current position as explored
                if (!this.gameState.map.explored.has(key)) {
                    this.gameState.map.explored.add(key);
                    this.gameState.stats.areasExplored++;
                    
                    // Update quest progress
                    this.updateExploreQuests();
                }
                
                // Explore visible radius
                for (let dx = -this.gameState.map.visibleRadius; dx <= this.gameState.map.visibleRadius; dx++) {
                    for (let dy = -this.gameState.map.visibleRadius; dy <= this.gameState.map.visibleRadius; dy++) {
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance <= this.gameState.map.visibleRadius) {
                            const exploreKey = `${x + dx},${y + dy}`;
                            if (!this.gameState.map.explored.has(exploreKey)) {
                                this.gameState.map.explored.add(exploreKey);
                                this.gameState.stats.areasExplored++;
                            }
                        }
                    }
                }
            }
            
            updateExploreQuests() {
                this.gameState.quests.forEach(quest => {
                    if (!quest.active || quest.completed) return;
                    
                    quest.objectives.forEach(objective => {
                        if (objective.completed || objective.target !== 'explore') return;
                        
                        objective.progress = this.gameState.stats.areasExplored;
                        if (objective.progress >= objective.amount) {
                            objective.completed = true;
                            this.gameState.log(`Objective completed: ${objective.description}`, 'event');
                        }
                    });
                });
            }
            
            checkEncounters(x, y) {
                const key = `${x},${y}`;
                
                // Check for locations
                const location = this.gameState.map.locations.get(key);
                if (location) {
                    this.gameState.log(`Discovered ${location.name}: ${location.description}`, 'event');
                    
                    if (location.loot) {
                        this.generateLoot();
                    }
                }
                
                // Check for resource nodes
                const resource = this.gameState.map.resources.get(key);
                if (resource && resource.amount > 0) {
                    this.gameState.log(`Found ${resource.type} deposit (${resource.amount} remaining)`, 'event');
                }
                
                // Check for enemies
                const enemy = this.gameState.map.enemies.get(key);
                if (enemy && enemy.health > 0) {
                    this.gameState.log(`Encountered ${enemy.name}!`, 'combat');
                    this.initiateCombat(enemy);
                }
                
                // Random encounters
                if (Math.random() < 0.1) {
                    this.randomEncounter();
                }
            }
            
            generateLoot() {
                const lootTable = [
                    { resource: 'solari', amount: () => Math.floor(Math.random() * 50) + 25 },
                    { resource: 'spice', amount: () => Math.floor(Math.random() * 20) + 10 },
                    { resource: 'water', amount: () => Math.floor(Math.random() * 15) + 5 },
                    { resource: 'plasteel', amount: () => Math.floor(Math.random() * 10) + 3 }
                ];
                
                const loot = lootTable[Math.floor(Math.random() * lootTable.length)];
                const amount = loot.amount();
                
                this.gameState.resources[loot.resource] += amount;
                this.gameState.log(`Found ${amount} ${loot.resource}!`, 'success');
            }
            
            randomEncounter() {
                const encounters = [
                    { message: 'A desert wind reveals a small spice cache', reward: { spice: 5 } },
                    { message: 'You find a abandoned water container', reward: { water: 3 } },
                    { message: 'Scavenged materials from old equipment', reward: { plasteel: 2 } },
                    { message: 'A Fremen trader offers a small gift', reward: { solari: 15 } }
                ];
                
                const encounter = encounters[Math.floor(Math.random() * encounters.length)];
                this.gameState.log(encounter.message, 'event');
                
                Object.entries(encounter.reward).forEach(([resource, amount]) => {
                    this.gameState.resources[resource] += amount;
                });
            }
            
            initiateCombat(enemy) {
                this.gameState.combat.active = true;
                this.gameState.combat.enemy = { ...enemy };
                this.gameState.combat.playerTurn = true;
                this.gameState.combat.messages = [`Combat initiated with ${enemy.name}!`];
                
                // Show combat UI
                document.getElementById('combatModal').classList.remove('hidden');
                this.updateCombatUI();
            }
            
            updateCombatUI() {
                if (!this.gameState.combat.active) return;
                
                const enemy = this.gameState.combat.enemy;
                const player = this.gameState.player;
                
                document.getElementById('combatEnemyName').textContent = enemy.name;
                document.getElementById('combatEnemyHealth').textContent = `${enemy.health} / ${enemy.maxHealth || enemy.health}`;
                document.getElementById('combatPlayerHealth').textContent = `${Math.floor(player.health)} / ${player.maxHealth}`;
                
                // Update health bars
                const enemyHealthPercent = (enemy.health / (enemy.maxHealth || enemy.health)) * 100;
                const playerHealthPercent = (player.health / player.maxHealth) * 100;
                
                document.getElementById('combatEnemyHealthBar').style.width = `${enemyHealthPercent}%`;
                document.getElementById('combatPlayerHealthBar').style.width = `${playerHealthPercent}%`;
                
                // Update combat log
                const logContainer = document.getElementById('combatLog');
                logContainer.innerHTML = this.gameState.combat.messages.map(msg => `<p class="text-sm">${msg}</p>`).join('');
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Update button states
                document.getElementById('combatAttackBtn').disabled = !this.gameState.combat.playerTurn;
                document.getElementById('combatFleeBtn').disabled = !this.gameState.combat.playerTurn;
            }
        }

        // ===== MAP RENDERING SYSTEM =====
        class MapRenderer {
            constructor(gameState) {
                this.gameState = gameState;
                this.cellSize = 24; // Smaller cell size
                this.zoomLevel = 1;
                this.minimapCellSize = 2; // Tiny cells for minimap
            }
            
            render() {
                const container = document.getElementById('mapContainer');
                if (!container) return;
                
                container.innerHTML = '';
                container.style.gridTemplateColumns = `repeat(${this.gameState.map.width}, ${this.cellSize * this.zoomLevel}px)`;
                container.style.gridGap = `${1 * this.zoomLevel}px`;
                container.className = 'map-grid';
                
                const playerPos = this.gameState.player.position;
                
                for (let y = 0; y < this.gameState.map.height; y++) {
                    for (let x = 0; x < this.gameState.map.width; x++) {
                        const cell = this.createMapCell(x, y, playerPos);
                        container.appendChild(cell);
                    }
                }
                
                // Render minimap
                this.renderMinimap();
                
                // Center view on player
                this.centerOnPlayer();
            }
            
            createMapCell(x, y, playerPos) {
                const cell = document.createElement('div');
                cell.className = 'map-cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                cell.style.width = `${this.cellSize * this.zoomLevel}px`;
                cell.style.height = `${this.cellSize * this.zoomLevel}px`;
                cell.style.fontSize = `${0.7 * this.zoomLevel}rem`;
                
                const key = `${x},${y}`;
                const isExplored = this.gameState.map.explored.has(key);
                const isPlayerCell = playerPos.x === x && playerPos.y === y;
                const distanceToPlayer = Math.sqrt(Math.pow(playerPos.x - x, 2) + Math.pow(playerPos.y - y, 2));
                
                // Add grid coordinates for orientation
                if (this.zoomLevel >= 1 && (x % 5 === 0 && y % 5 === 0)) {
                    cell.dataset.coords = `${x},${y}`;
                }
                
                // Determine cell appearance
                if (!isExplored && distanceToPlayer > this.gameState.map.visibleRadius + 1) {
                    // Unexplored and far
                    cell.classList.add('bg-stone-900', 'text-stone-700');
                    cell.textContent = '';
                } else if (!isExplored) {
                    // Unexplored but visible
                    cell.classList.add('bg-stone-800', 'text-stone-600');
                    cell.textContent = '?';
                } else {
                    // Explored
                    cell.classList.add('bg-amber-800', 'hover:bg-amber-700', 'text-amber-200');
                    
                    // Check for special features
                    this.addCellFeatures(cell, x, y, key);
                }
                
                // Player position
                if (isPlayerCell) {
                    cell.innerHTML = 'ðŸ¤ ';
                    cell.classList.add('bg-yellow-500', 'text-black', 'player-indicator');
                    cell.title = `${this.gameState.player.name} (You)`;
                }
                
                // Add click handler for movement
                if (!isPlayerCell && isExplored) {
                    cell.addEventListener('click', () => this.handleCellClick(x, y));
                }
                
                return cell;
            }
            
            renderMinimap() {
                const container = document.getElementById('minimapContainer');
                if (!container) return;
                
                container.innerHTML = '';
                container.style.position = 'relative';
                
                const playerPos = this.gameState.player.position;
                
                // Create minimap canvas
                const canvas = document.createElement('canvas');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                container.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                const cellWidth = canvas.width / this.gameState.map.width;
                const cellHeight = canvas.height / this.gameState.map.height;
                
                // Draw explored areas
                ctx.fillStyle = '#78716c'; // stone-500
                this.gameState.map.explored.forEach(key => {
                    const [x, y] = key.split(',').map(Number);
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                });
                
                // Draw locations
                this.gameState.map.locations.forEach((location, key) => {
                    const [x, y] = key.split(',').map(Number);
                    ctx.fillStyle = location.friendly ? '#15803d' : '#b91c1c'; // green-700 or red-700
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                });
                
                // Draw resources
                this.gameState.map.resources.forEach((resource, key) => {
                    const [x, y] = key.split(',').map(Number);
                    ctx.fillStyle = '#ea580c'; // orange-600
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                });
                
                // Draw enemies
                this.gameState.map.enemies.forEach((enemy, key) => {
                    const [x, y] = key.split(',').map(Number);
                    ctx.fillStyle = '#dc2626'; // red-600
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                });
                
        // Draw player position
        ctx.fillStyle = '#eab308'; // yellow-500
        ctx.fillRect(playerPos.x * cellWidth - 1, playerPos.y * cellHeight - 1, cellWidth + 2, cellHeight + 2);
        
        // Draw viewport indicator
        const viewportWidth = Math.min(15, this.gameState.map.width);
        const viewportHeight = Math.min(15, this.gameState.map.height);
        
        // Calculate viewport center based on scroll position
        const mapContainer = document.querySelector('.map-scroll-container');
        let viewX = playerPos.x;
        let viewY = playerPos.y;
        
        if (mapContainer) {
            const scrollLeft = mapContainer.scrollLeft;
            const scrollTop = mapContainer.scrollTop;
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            viewX = Math.floor(scrollLeft / (this.cellSize * this.zoomLevel)) + Math.floor(containerWidth / (this.cellSize * this.zoomLevel * 2));
            viewY = Math.floor(scrollTop / (this.cellSize * this.zoomLevel)) + Math.floor(containerHeight / (this.cellSize * this.zoomLevel * 2));
        }
        
        // Draw viewport rectangle
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(
            (viewX - viewportWidth/2) * cellWidth,
            (viewY - viewportHeight/2) * cellHeight,
            viewportWidth * cellWidth,
            viewportHeight * cellHeight
        );
        
        // Add click handler to minimap for navigation
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellWidth);
            const y = Math.floor((e.clientY - rect.top) / cellHeight);
            
            // Scroll main map to this position
            this.scrollToPosition(x, y);
        });
    }
    
    scrollToPosition(x, y) {
        const mapContainer = document.querySelector('.map-scroll-container');
        if (!mapContainer) return;
        
        const scrollX = x * this.cellSize * this.zoomLevel - mapContainer.clientWidth / 2;
        const scrollY = y * this.cellSize * this.zoomLevel - mapContainer.clientHeight / 2;
        
        mapContainer.scrollTo({
            left: Math.max(0, scrollX),
            top: Math.max(0, scrollY),
            behavior: 'smooth'
        });
    }
    
    centerOnPlayer() {
        const playerPos = this.gameState.player.position;
        this.scrollToPosition(playerPos.x, playerPos.y);
    }
    
    zoomIn() {
        if (this.zoomLevel < 2) {
            this.zoomLevel += 0.25;
            this.render();
        }
    }
    
    zoomOut() {
        if (this.zoomLevel > 0.5) {
            this.zoomLevel -= 0.25;
            this.render();
        }
    }
    
    addCellFeatures(cell, x, y, key) {
        // Locations
        const location = this.gameState.map.locations.get(key);
        if (location) {
            const icons = {
                settlement: 'ðŸ ',
                ruins: 'ðŸ›ï¸',
                oasis: 'ðŸ’§',
                outpost: 'ðŸ­'
            };
            
            cell.innerHTML = icons[location.type] || 'ðŸ“';
            cell.classList.add(location.friendly ? 'bg-green-700' : 'bg-red-700', 'text-white');
            cell.title = location.name;
            return;
        }
        
        // Resource nodes
        const resource = this.gameState.map.resources.get(key);
        if (resource && resource.amount > 0) {
            const icons = {
                spice: 'âœ¨',
                water: 'ðŸ’§',
                plasteel: 'ðŸ”©'
            };
            
            cell.innerHTML = icons[resource.type] || 'ðŸ’Ž';
            cell.classList.add('bg-orange-600', 'text-white');
            cell.title = `${resource.type} (${resource.amount})`;
            
            // Add resource indicator
            const indicator = document.createElement('div');
            indicator.className = 'resource-indicator bg-orange-400';
            cell.appendChild(indicator);
            
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                this.harvestResource(x, y);
            });
            return;
        }
        
        // Enemies
        const enemy = this.gameState.map.enemies.get(key);
        if (enemy && enemy.health > 0) {
            cell.innerHTML = 'ðŸ’€';
            cell.classList.add('bg-red-600', 'text-white');
            cell.title = enemy.name;
            return;
        }
    }
    
    handleCellClick(x, y) {
        const movementSystem = new MovementSystem(this.gameState);
        if (movementSystem.movePlayer(x, y)) {
            this.render();
            uiManager.updateAll();
        }
    }
    
    harvestResource(x, y) {
        const key = `${x},${y}`;
        const resource = this.gameState.map.resources.get(key);
        
        if (!resource || resource.amount <= 0) {
            this.gameState.log('No resources to harvest here', 'warning');
            return;
        }
        
        // Check if player is adjacent
        const playerPos = this.gameState.player.position;
        const distance = Math.abs(playerPos.x - x) + Math.abs(playerPos.y - y);
        
        if (distance > 1) {
            this.gameState.log('Must be adjacent to harvest resources', 'warning');
            return;
        }
        
        // Harvest resource
        const harvestAmount = Math.min(resource.amount, Math.floor(Math.random() * 10) + 5);
        resource.amount -= harvestAmount;
        this.gameState.resources[resource.type] += harvestAmount;
        
        this.gameState.log(`Harvested ${harvestAmount} ${resource.type}`, 'success');
        
        // Remove depleted resource
        if (resource.amount <= 0) {
            this.gameState.map.resources.delete(key);
            this.gameState.log(`${resource.type} deposit depleted`, 'info');
        }
        
        this.render();
        uiManager.updateAll();
    }
}
