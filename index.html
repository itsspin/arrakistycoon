<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrakis Tycoon MMO - The Spice Must Flow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #1c1917; color: #e5e7eb; }
        .font-orbitron { font-family: 'Orbitron', sans-serif; }
        .tab-button { transition: all 0.2s ease-in-out; }
        .tab-button.active { border-bottom-color: #f59e0b; color: #f59e0b; background-color: #292524; }
        .progress-bar-bg { background-color: #3f3f46; }
        .progress-bar-fill { background-color: #f59e0b; transition: width 0.3s ease; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #292524; border-radius: 4px;}
        ::-webkit-scrollbar-thumb { background: #52525b; border-radius: 4px;}
        ::-webkit-scrollbar-thumb:hover { background: #71717a; }

        .map-grid { 
            display: grid; 
            grid-template-columns: repeat(15, 28px);
            gap: 0px;
            background-color: #0c0a09;
            border: 1px solid #44403c;
            margin: 0 auto;
        }
        .map-cell { 
            width: 28px; height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem; 
            font-weight: bold;
            border: 1px solid #292524;
            cursor: pointer;
            transition: background-color 0.1s, transform 0.1s;
            position: relative;
        }
        .map-cell:hover {
            transform: scale(1.05);
            z-index: 10;
            border-color: #f59e0b !important;
        }
        .map-cell-unexplored { background-color: #0c0a09; color: #1c1917; }
        .map-cell-explored { background-color: #78350f; color: #eab308; }
        .map-cell-player { background-color: #facc15 !important; color: black !important; box-shadow: 0 0 8px #facc15; }
        .map-cell-other-player { background-color: #8b5cf6 !important; color: white !important; }
        .map-cell-enemy { background-color: #ef4444 !important; color: white !important; }
        .map-cell-boss { background-color: #7e22ce !important; color: white !important; animation: pulse-boss 2s infinite alternate; }
        .map-cell-resource-spice { background-color: #ea580c !important; color: #fed7aa !important; }
        .map-cell-resource-water { background-color: #0ea5e9 !important; color: white !important; }
        .map-cell-resource-plasteel { background-color: #64748b !important; color: white !important; }
        .map-cell-settlement { background-color: #16a34a !important; color: white !important; }
        .map-cell-ruins { background-color: #6b7280 !important; color: white !important; }
        .map-cell-player-base { border: 2px dashed #059669 !important; }
        .map-cell-other-player-base { border: 2px dashed #dc2626 !important; }

        @keyframes pulse-boss { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }

        .notification {
            position: fixed; top: 20px; right: 20px; z-index: 10000;
            padding: 10px 15px; border-radius: 6px; color: white; font-weight: 500;
            transform: translateX(120%); opacity: 0;
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
            min-width: 250px; max-width: 350px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .notification.show { transform: translateX(0); opacity: 1;}
        .notification.success { background-color: #10b981; }
        .notification.error { background-color: #ef4444; }
        .notification.warning { background-color: #f59e0b; color: #1c1917; }
        .notification.info { background-color: #3b82f6; }

        .modal-overlay { position: fixed; inset: 0; background-color: rgba(0,0,0,0.75); z-index: 5000; display: flex; align-items: center; justify-content: center; }
        .modal-content { background-color: #1c1917; border: 1px solid #44403c; border-radius: 8px; padding: 20px; max-width: 500px; width: 90%; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        
        .inventory-slot {
            width: 48px; height: 48px; border: 1px solid #44403c; background: #292524;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            transition: all 0.1s; position: relative; border-radius: 4px;
            font-size: 1.2rem;
        }
        .inventory-slot:hover { border-color: #f59e0b; transform: scale(1.05); }
        .item-tooltip {
            position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-5px);
            background-color: #1c1917; border: 1px solid #f59e0b; padding: 8px; border-radius: 4px;
            font-size: 0.75rem; white-space: nowrap; z-index: 6000; display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .inventory-slot:hover .item-tooltip { display: block; }

        .ability-slot {
            width: 56px; height: 56px; border: 1px solid #44403c; background: #292524;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.1s; position: relative; border-radius: 4px;
        }
        .ability-slot:hover:not(.cooldown) { border-color: #f59e0b; transform: scale(1.05); }
        .ability-slot.cooldown { opacity: 0.5; cursor: not-allowed; }
        .ability-icon { font-size: 1.5rem; }
        .ability-cooldown-text { position: absolute; bottom: 2px; font-size: 0.65rem; color: #facc15; }

        .minimap {
            width: 150px; height: 150px;
            background: #0c0a09; border: 1px solid #44403c;
            position: relative; margin: 0 auto;
        }
        .minimap-dot {
            position: absolute; width: 3px; height: 3px; border-radius: 50%;
        }
        .minimap-player { background: #facc15; box-shadow: 0 0 4px #facc15; }
        .minimap-enemy { background: #ef4444; }
        .minimap-resource { background: #ea580c; }
        .minimap-other-player { background: #8b5cf6; }
    </style>
</head>
<body class="bg-stone-950 text-stone-300 antialiased">

    <script type="module">
        // === FIREBASE CONFIGURATION ===
        const firebaseConfig = {
            apiKey: "demo-api-key",
            authDomain: "demo.firebaseapp.com", 
            projectId: "demo-project",
            storageBucket: "demo-project.appspot.com",
            messagingSenderId: "123456789",
            appId: "demo-app-id"
        };

        // === GAME CONSTANTS ===
        const CONFIG = {
            MAP_SIZE: 100,
            VIEW_RADIUS: 7,
            MAX_INVENTORY: 24,
            ENERGY_REGEN_RATE: 1,
            ENERGY_REGEN_INTERVAL: 5000,
            SAVE_INTERVAL: 30000,
            XP_BASE: 100,
            XP_FACTOR: 1.5,
            SPICE_BASE_PRICE: 5,
            WATER_CONSUMPTION_MOVE: 2,
            INITIAL_RESOURCES: { spice: 0, water: 100, solari: 500, plasteel: 50, rareMaterials: 0 }
        };

        const STATIC_DATA = {
            RANKS: [
                { name: 'Novice', minPower: 0, color: 'text-stone-400' },
                { name: 'Scout', minPower: 500, color: 'text-lime-400' },
                { name: 'Warrior', minPower: 2000, color: 'text-emerald-400' },
                { name: 'Veteran', minPower: 5000, color: 'text-teal-400' },
                { name: 'Elite', minPower: 10000, color: 'text-cyan-400' },
                { name: 'Baron', minPower: 25000, color: 'text-sky-400' },
                { name: 'Duke', minPower: 50000, color: 'text-blue-400' },
                { name: 'Kwisatz Haderach', minPower: 100000, color: 'text-violet-400 font-bold' }
            ],
            BUILDINGS: {
                refinery: { name: "Spice Refinery", icon: "üè≠", maxLevel: 10, baseCost: { solari: 300, plasteel: 20 }, costFactor: 1.8 },
                shieldWall: { name: "Shield Wall", icon: "üõ°Ô∏è", maxLevel: 10, baseCost: { solari: 500, plasteel: 50 }, costFactor: 2.0 },
                market: { name: "Trading Post", icon: "üè™", maxLevel: 5, baseCost: { solari: 200, plasteel: 10 }, costFactor: 1.7 },
                bank: { name: "Solari Bank", icon: "üè¶", maxLevel: 5, baseCost: { solari: 1000, plasteel: 0 }, costFactor: 2.5 },
                researchLab: { name: "Research Lab", icon: "üî¨", maxLevel: 5, baseCost: { solari: 800, plasteel: 100 }, costFactor: 2.2 }
            },
            ABILITIES: {
                sandstorm: { name: "Sandstorm", icon: "üå™Ô∏è", energyCost: 20, cooldown: 30000, damage: 25, type: 'aoe' },
                crysknife: { name: "Crysknife Strike", icon: "üó°Ô∏è", energyCost: 15, cooldown: 20000, damage: 35, type: 'single', critBonus: 50 },
                shield: { name: "Shield Wall", icon: "üõ°Ô∏è", energyCost: 10, cooldown: 25000, defense: 20, type: 'defense' },
                waterOfLife: { name: "Water of Life", icon: "üíß", energyCost: 25, cooldown: 45000, heal: 40, type: 'heal' }
            },
            ENEMIES: {
                sandRaider: { name: "Sand Raider", icon: "üèπ", health: 50, attack: 12, defense: 5, xp: 25, loot: { solari: 20, spice: 5 } },
                harkonnenScout: { name: "Harkonnen Scout", icon: "üë§", health: 75, attack: 18, defense: 8, xp: 40, loot: { solari: 35, plasteel: 3 } },
                sardaukar: { name: "Sardaukar", icon: "‚öîÔ∏è", health: 120, attack: 25, defense: 12, xp: 80, loot: { solari: 80, rareMaterials: 1 } },
                beastRabban: { name: "Beast Rabban", icon: "üëπ", health: 300, attack: 40, defense: 20, xp: 200, loot: { solari: 500, spice: 50, rareMaterials: 5 }, boss: true }
            },
            ITEMS: {
                rustyBlade: { name: "Rusty Blade", icon: "üî™", type: "weapon", attack: 5, rarity: "common" },
                crysknife: { name: "Crysknife", icon: "üó°Ô∏è", type: "weapon", attack: 15, rarity: "rare" },
                stillsuit: { name: "Stillsuit", icon: "ü•Ω", type: "armor", defense: 8, rarity: "uncommon" },
                shieldBelt: { name: "Shield Belt", icon: "üîò", type: "accessory", defense: 12, rarity: "epic" }
            }
        };

        // === GAME STATE ===
        let gameState = {
            player: {
                id: null, name: "Survivor", level: 1, experience: 0, experienceToNext: 100,
                health: 100, maxHealth: 100, energy: 100, maxEnergy: 100,
                attack: 10, defense: 5, critChance: 5, dodgeChance: 10,
                position: { x: 50, y: 50 }, basePosition: { x: 50, y: 50 },
                rank: 'Novice', power: 0, pvpEnabled: false,
                abilities: [], selectedAbilities: [null, null, null],
                lastRaidTime: 0, raidProtectionEnds: 0
            },
            resources: { ...CONFIG.INITIAL_RESOURCES },
            equipment: { weapon: null, armor: null, accessory: null },
            inventory: new Array(CONFIG.MAX_INVENTORY).fill(null),
            buildings: { refinery: 0, shieldWall: 0, market: 0, bank: 0, researchLab: 0 },
            map: {
                viewRadius: CONFIG.VIEW_RADIUS,
                explored: {},
                enemies: {},
                resources: {},
                players: {}
            },
            combat: { active: false, enemy: null, turn: 'player', log: [] },
            trade: { active: false, partnerId: null, myOffer: {}, theirOffer: {}, confirmed: false },
            enhancement: { item: null, itemIndex: -1 },
            chat: { messages: [] },
            rankings: { topSpice: [], topLevel: [], topPower: [] },
            isLoading: true,
            gameInitialized: false,
            currentTab: 'game',
            abilityCooldowns: {},
            lastSaveTime: 0,
            lastEnergyRegen: Date.now(),
            gameLog: []
        };

        // === FIREBASE SIMULATION (For Demo) ===
        let mockFirestore = {
            players: {},
            chat: [],
            enemies: {},
            resources: {},
            duels: {},
            trades: {}
        };

        // === UTILITY FUNCTIONS ===
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        function getRandomPosition() {
            return {
                x: Math.floor(Math.random() * CONFIG.MAP_SIZE),
                y: Math.floor(Math.random() * CONFIG.MAP_SIZE)
            };
        }

        function calculateDistance(pos1, pos2) {
            return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
        }

        function calculatePlayerPower() {
            let power = gameState.player.level * 10;
            power += gameState.player.attack * 2;
            power += gameState.player.defense * 2;
            
            // Equipment bonuses
            Object.values(gameState.equipment).forEach(item => {
                if (item) {
                    power += (item.attack || 0) * 3;
                    power += (item.defense || 0) * 3;
                }
            });

            // Building bonuses
            power += Object.values(gameState.buildings).reduce((sum, level) => sum + level * 5, 0);

            gameState.player.power = Math.floor(power);
            return power;
        }

        function updatePlayerRank() {
            const power = calculatePlayerPower();
            const ranks = STATIC_DATA.RANKS;
            
            for (let i = ranks.length - 1; i >= 0; i--) {
                if (power >= ranks[i].minPower) {
                    gameState.player.rank = ranks[i].name;
                    break;
                }
            }
        }

        function calculateXPNeeded(level) {
            return Math.floor(CONFIG.XP_BASE * Math.pow(CONFIG.XP_FACTOR, level - 1));
        }

        function addExperience(amount) {
            gameState.player.experience += amount;
            logEvent(`Gained ${amount} XP!`);
            
            while (gameState.player.experience >= gameState.player.experienceToNext) {
                levelUp();
            }
        }

        function levelUp() {
            gameState.player.level++;
            gameState.player.experience -= gameState.player.experienceToNext;
            gameState.player.experienceToNext = calculateXPNeeded(gameState.player.level + 1);
            
            // Stat increases
            gameState.player.maxHealth += 10;
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.maxEnergy += 5;
            gameState.player.energy = gameState.player.maxEnergy;
            gameState.player.attack += 2;
            gameState.player.defense += 1;

            logEvent(`üåü LEVEL UP! You are now level ${gameState.player.level}!`);
            showNotification(`Level Up! Now level ${gameState.player.level}`, 'success');
            
            updatePlayerRank();
        }

        function logEvent(message) {
            const timestamp = new Date().toLocaleTimeString();
            gameState.gameLog.unshift(`[${timestamp}] ${message}`);
            if (gameState.gameLog.length > 50) gameState.gameLog.pop();
            updateGameLog();
        }

        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            const container = document.getElementById('notificationContainer') || document.body;
            container.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => container.removeChild(notification), 400);
            }, duration);
        }

        // === RESOURCE MANAGEMENT ===
        function updateResources(changes) {
            Object.entries(changes).forEach(([resource, amount]) => {
                if (gameState.resources[resource] !== undefined) {
                    gameState.resources[resource] = Math.max(0, gameState.resources[resource] + amount);
                }
            });
            updateResourceDisplay();
        }

        function canAfford(costs) {
            return Object.entries(costs).every(([resource, amount]) => 
                gameState.resources[resource] >= amount
            );
        }

        function spendResources(costs) {
            if (!canAfford(costs)) return false;
            Object.entries(costs).forEach(([resource, amount]) => {
                gameState.resources[resource] -= amount;
            });
            updateResourceDisplay();
            return true;
        }

        function harvestResource(type) {
            const energyCost = { spice: 5, water: 8, plasteel: 12, rareMaterials: 20 }[type] || 5;
            const baseAmount = { spice: 3, water: 5, plasteel: 2, rareMaterials: 1 }[type] || 1;
            
            if (gameState.player.energy < energyCost) {
                showNotification('Not enough energy!', 'error');
                return;
            }

            gameState.player.energy -= energyCost;
            const amount = baseAmount + Math.floor(gameState.player.level / 5);
            updateResources({ [type]: amount });
            
            logEvent(`Harvested ${amount} ${type}`);
            showNotification(`+${amount} ${type}`, 'success');
        }

        // === MAP SYSTEM ===
        function initializeMap() {
            // Generate some initial enemies and resources
            for (let i = 0; i < 50; i++) {
                const pos = getRandomPosition();
                const key = `${pos.x},${pos.y}`;
                
                if (Math.random() < 0.3) { // Enemy
                    const enemyTypes = Object.keys(STATIC_DATA.ENEMIES);
                    const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    gameState.map.enemies[key] = {
                        id: generateId(),
                        type: enemyType,
                        position: pos,
                        ...STATIC_DATA.ENEMIES[enemyType]
                    };
                } else { // Resource
                    const resourceTypes = ['spice', 'water', 'plasteel'];
                    const resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                    gameState.map.resources[key] = {
                        id: generateId(),
                        type: resourceType,
                        position: pos,
                        amount: 10 + Math.floor(Math.random() * 20)
                    };
                }
            }
        }

        function renderMap() {
            const mapGrid = document.getElementById('uiMapGrid');
            if (!mapGrid) return;
            
            mapGrid.innerHTML = '';
            
            const playerX = gameState.player.position.x;
            const playerY = gameState.player.position.y;
            const radius = gameState.map.viewRadius;
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const x = playerX + dx;
                    const y = playerY + dy;
                    const key = `${x},${y}`;
                    
                    const cell = document.createElement('div');
                    cell.className = 'map-cell map-cell-explored';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    // Player position
                    if (x === playerX && y === playerY) {
                        cell.className += ' map-cell-player';
                        cell.textContent = 'üë§';
                    }
                    // Enemy
                    else if (gameState.map.enemies[key]) {
                        const enemy = gameState.map.enemies[key];
                        cell.className += enemy.boss ? ' map-cell-boss' : ' map-cell-enemy';
                        cell.textContent = enemy.icon;
                        cell.title = enemy.name;
                    }
                    // Resource
                    else if (gameState.map.resources[key]) {
                        const resource = gameState.map.resources[key];
                        cell.className += ` map-cell-resource-${resource.type}`;
                        cell.textContent = { spice: '‚ú®', water: 'üíß', plasteel: 'üîß' }[resource.type] || 'üì¶';
                        cell.title = `${resource.type} (${resource.amount})`;
                    }
                    // Other players (simulated)
                    else if (Math.random() < 0.01) {
                        cell.className += ' map-cell-other-player';
                        cell.textContent = 'üë•';
                        cell.title = 'Another Player';
                    }
                    // Empty desert
                    else {
                        cell.textContent = 'üèúÔ∏è';
                    }
                    
                    cell.addEventListener('click', () => handleCellClick(parseInt(x), parseInt(y)));
                    mapGrid.appendChild(cell);
                }
            }
            
            // Update coordinates display
            const coordsDisplay = document.getElementById('mapPlayerCoords');
            if (coordsDisplay) {
                coordsDisplay.textContent = `${playerX},${playerY}`;
            }
        }

        function handleCellClick(x, y) {
            const key = `${x},${y}`;
            const dx = x - gameState.player.position.x;
            const dy = y - gameState.player.position.y;
            
            // Only allow movement to adjacent cells
            if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1 && (dx !== 0 || dy !== 0)) {
                movePlayer(dx, dy);
            }
            // Interact with objects on current position
            else if (dx === 0 && dy === 0) {
                if (gameState.map.enemies[key]) {
                    startCombat(gameState.map.enemies[key]);
                } else if (gameState.map.resources[key]) {
                    harvestResourceNode(gameState.map.resources[key]);
                }
            }
        }

        function movePlayer(dx, dy) {
            if (gameState.combat.active) {
                showNotification('Cannot move during combat!', 'error');
                return;
            }
            
            if (gameState.resources.water < CONFIG.WATER_CONSUMPTION_MOVE) {
                showNotification('Not enough water to move!', 'error');
                return;
            }
            
            const newX = Math.max(0, Math.min(CONFIG.MAP_SIZE - 1, gameState.player.position.x + dx));
            const newY = Math.max(0, Math.min(CONFIG.MAP_SIZE - 1, gameState.player.position.y + dy));
            
            gameState.player.position.x = newX;
            gameState.player.position.y = newY;
            updateResources({ water: -CONFIG.WATER_CONSUMPTION_MOVE });
            
            // Check for encounters
            const key = `${newX},${newY}`;
            if (gameState.map.enemies[key] && Math.random() < 0.3) {
                startCombat(gameState.map.enemies[key]);
                return;
            }
            
            renderMap();
            logEvent(`Moved to ${newX},${newY}`);
        }

        function harvestResourceNode(resource) {
            if (gameState.player.energy < 10) {
                showNotification('Not enough energy!', 'error');
                return;
            }
            
            gameState.player.energy -= 10;
            const amount = Math.min(5, resource.amount);
            resource.amount -= amount;
            
            updateResources({ [resource.type]: amount });
            logEvent(`Harvested ${amount} ${resource.type} from node`);
            
            if (resource.amount <= 0) {
                const key = `${resource.position.x},${resource.position.y}`;
                delete gameState.map.resources[key];
                logEvent('Resource node depleted');
            }
            
            renderMap();
        }

        // === COMBAT SYSTEM ===
        function startCombat(enemy) {
            gameState.combat = {
                active: true,
                enemy: { ...enemy },
                turn: 'player',
                log: []
            };
            
            addCombatLog(`Combat started with ${enemy.name}!`);
            showCombatModal();
        }

        function showCombatModal() {
            const modal = document.getElementById('modalCombat');
            if (!modal) return;
            
            modal.classList.remove('hidden');
            updateCombatDisplay();
        }

        function updateCombatDisplay() {
            // Update player stats
            document.getElementById('modalCombatPlayerName').textContent = gameState.player.name;
            document.getElementById('modalCombatPlayerLevel').textContent = `Lv.${gameState.player.level}`;
            document.getElementById('modalCombatPlayerHealth').textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
            document.getElementById('modalCombatPlayerEnergy').textContent = `${gameState.player.energy}/${gameState.player.maxEnergy}`;
            
            // Update enemy stats
            const enemy = gameState.combat.enemy;
            document.getElementById('modalCombatEnemyName').textContent = enemy.name;
            document.getElementById('modalCombatEnemyLevel').textContent = `Lv.${enemy.level || 1}`;
            document.getElementById('modalCombatEnemyHealth').textContent = `${enemy.health}/${enemy.maxHealth || enemy.health}`;
            
            // Update health bars
            const playerHealthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const enemyHealthPercent = (enemy.health / (enemy.maxHealth || enemy.health)) * 100;
            
            document.getElementById('modalCombatPlayerHealthBar').style.width = `${playerHealthPercent}%`;
            document.getElementById('modalCombatEnemyHealthBar').style.width = `${enemyHealthPercent}%`;
            
            // Update energy bar
            const energyPercent = (gameState.player.energy / gameState.player.maxEnergy) * 100;
            document.getElementById('modalCombatPlayerEnergyBar').style.width = `${energyPercent}%`;
            
            // Update combat log
            const logElement = document.getElementById('modalCombatLog');
            if (logElement) {
                logElement.innerHTML = gameState.combat.log.join('<br>');
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            // Update turn indicator
            const turnIndicator = document.getElementById('modalCombatTurnIndicator');
            if (turnIndicator) {
                turnIndicator.textContent = gameState.combat.turn === 'player' ? "Your Turn" : "Enemy's Turn";
            }
            
            // Enable/disable action buttons
            const isPlayerTurn = gameState.combat.turn === 'player';
            document.getElementById('combatActionAttack').disabled = !isPlayerTurn;
            document.getElementById('combatActionDefend').disabled = !isPlayerTurn;
            document.getElementById('combatActionFlee').disabled = !isPlayerTurn;
        }

        function addCombatLog(message) {
            gameState.combat.log.push(message);
            if (gameState.combat.log.length > 20) gameState.combat.log.shift();
        }

        function combatAction(action) {
            if (gameState.combat.turn !== 'player') return;
            
            const enemy = gameState.combat.enemy;
            let damage = 0;
            
            switch (action) {
                case 'attack':
                    damage = gameState.player.attack + Math.floor(Math.random() * 10);
                    if (Math.random() * 100 < gameState.player.critChance) {
                        damage *= 2;
                        addCombatLog(`üí• Critical hit! You deal ${damage} damage!`);
                    } else {
                        addCombatLog(`‚öîÔ∏è You attack for ${damage} damage!`);
                    }
                    enemy.health -= damage;
                    break;
                    
                case 'defend':
                    const healing = Math.floor(gameState.player.maxHealth * 0.1);
                    gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healing);
                    addCombatLog(`üõ°Ô∏è You defend and recover ${healing} health!`);
                    break;
                    
                case 'flee':
                    if (Math.random() < 0.7) {
                        addCombatLog(`üí® You successfully flee from combat!`);
                        endCombat(false);
                        return;
                    } else {
                        addCombatLog(`‚ùå Failed to flee!`);
                    }
                    break;
            }
            
            // Check if enemy is defeated
            if (enemy.health <= 0) {
                endCombat(true);
                return;
            }
            
            // Enemy turn
            gameState.combat.turn = 'enemy';
            updateCombatDisplay();
            
            setTimeout(() => {
                enemyTurn();
            }, 1000);
        }

        function enemyTurn() {
            const enemy = gameState.combat.enemy;
            const damage = enemy.attack + Math.floor(Math.random() * 5);
            
            if (Math.random() * 100 < gameState.player.dodgeChance) {
                addCombatLog(`üí® You dodge ${enemy.name}'s attack!`);
            } else {
                const actualDamage = Math.max(1, damage - gameState.player.defense);
                gameState.player.health -= actualDamage;
                addCombatLog(`üíÄ ${enemy.name} attacks you for ${actualDamage} damage!`);
                
                if (gameState.player.health <= 0) {
                    endCombat(false);
                    return;
                }
            }
            
            gameState.combat.turn = 'player';
            updateCombatDisplay();
        }

        function endCombat(victory) {
            const enemy = gameState.combat.enemy;
            
            if (victory) {
                addCombatLog(`üéâ Victory! ${enemy.name} has been defeated!`);
                
                // Rewards
                addExperience(enemy.xp || 20);
                updateResources(enemy.loot || { solari: 10 });
                
                // Remove enemy from map
                const key = `${enemy.position.x},${enemy.position.y}`;
                delete gameState.map.enemies[key];
                
                showNotification(`Defeated ${enemy.name}!`, 'success');
                logEvent(`Defeated ${enemy.name} and gained ${enemy.xp || 20} XP`);
            } else {
                addCombatLog(`üíÄ Defeat! You have been defeated by ${enemy.name}!`);
                gameState.player.health = Math.floor(gameState.player.maxHealth * 0.1);
                showNotification('You were defeated!', 'error');
                logEvent(`Defeated by ${enemy.name}`);
            }
            
            gameState.combat.active = false;
            
            setTimeout(() => {
                document.getElementById('modalCombat').classList.add('hidden');
                renderMap();
            }, 2000);
        }

        // === BUILDING SYSTEM ===
        function buyBuilding(buildingType) {
            const building = STATIC_DATA.BUILDINGS[buildingType];
            if (!building) return;
            
            const currentLevel = gameState.buildings[buildingType];
            if (currentLevel >= building.maxLevel) {
                showNotification('Building at max level!', 'warning');
                return;
            }
            
            const cost = {};
            Object.entries(building.baseCost).forEach(([resource, amount]) => {
                cost[resource] = Math.floor(amount * Math.pow(building.costFactor, currentLevel));
            });
            
            if (!canAfford(cost)) {
                showNotification('Cannot afford building upgrade!', 'error');
                return;
            }
            
            spendResources(cost);
            gameState.buildings[buildingType]++;
            
            logEvent(`Upgraded ${building.name} to level ${gameState.buildings[buildingType]}`);
            showNotification(`${building.name} upgraded!`, 'success');
            updateBuildingsDisplay();
        }

        // === INVENTORY SYSTEM ===
        function addToInventory(item) {
            const emptySlot = gameState.inventory.findIndex(slot => slot === null);
            if (emptySlot === -1) {
                showNotification('Inventory full!', 'warning');
                return false;
            }
            
            gameState.inventory[emptySlot] = item;
            updateInventoryDisplay();
            return true;
        }

        function equipItem(item, inventoryIndex) {
            if (!item || !item.type) return;
            
            const equipSlot = item.type;
            const currentEquipped = gameState.equipment[equipSlot];
            
            // Unequip current item
            if (currentEquipped) {
                gameState.inventory[inventoryIndex] = currentEquipped;
            } else {
                gameState.inventory[inventoryIndex] = null;
            }
            
            // Equip new item
            gameState.equipment[equipSlot] = item;
            
            logEvent(`Equipped ${item.name}`);
            updateInventoryDisplay();
            updateEquipmentDisplay();
        }

        // === ABILITY SYSTEM ===
        function useAbility(abilityId) {
            const ability = STATIC_DATA.ABILITIES[abilityId];
            if (!ability) return;
            
            if (gameState.abilityCooldowns[abilityId] && gameState.abilityCooldowns[abilityId] > Date.now()) {
                showNotification('Ability on cooldown!', 'warning');
                return;
            }
            
            if (gameState.player.energy < ability.energyCost) {
                showNotification('Not enough energy!', 'error');
                return;
            }
            
            gameState.player.energy -= ability.energyCost;
            gameState.abilityCooldowns[abilityId] = Date.now() + ability.cooldown;
            
            // Apply ability effects (simplified)
            if (gameState.combat.active) {
                const enemy = gameState.combat.enemy;
                switch (ability.type) {
                    case 'aoe':
                    case 'single':
                        const damage = ability.damage + (ability.critBonus && Math.random() < 0.3 ? ability.critBonus : 0);
                        enemy.health -= damage;
                        addCombatLog(`üåü ${ability.name} deals ${damage} damage!`);
                        break;
                    case 'heal':
                        const healing = ability.heal;
                        gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healing);
                        addCombatLog(`üíß ${ability.name} heals you for ${healing} health!`);
                        break;
                    case 'defense':
                        addCombatLog(`üõ°Ô∏è ${ability.name} increases your defense!`);
                        break;
                }
                updateCombatDisplay();
            } else {
                showNotification(`Used ${ability.name}!`, 'info');
            }
            
            updateAbilityDisplay();
        }

        // === CHAT SYSTEM ===
        function sendChatMessage() {
            const input = document.getElementById('uiChatInput');
            if (!input || !input.value.trim()) return;
            
            const message = {
                id: generateId(),
                playerId: gameState.player.id,
                playerName: gameState.player.name,
                text: input.value.trim(),
                timestamp: Date.now()
            };
            
            gameState.chat.messages.push(message);
            input.value = '';
            
            updateChatDisplay();
            logEvent(`Sent chat message: ${message.text}`);
        }

        // === UI UPDATE FUNCTIONS ===
        function updateResourceDisplay() {
            Object.entries(gameState.resources).forEach(([resource, amount]) => {
                const element = document.getElementById(`resource${resource.charAt(0).toUpperCase() + resource.slice(1)}`);
                if (element) {
                    element.textContent = amount.toLocaleString();
                }
            });
        }

        function updatePlayerStats() {
            document.getElementById('statHealth').textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
            document.getElementById('statEnergy').textContent = `${gameState.player.energy}/${gameState.player.maxEnergy}`;
            document.getElementById('statLevel').textContent = gameState.player.level;
            document.getElementById('statExp').textContent = `${gameState.player.experience}/${gameState.player.experienceToNext}`;
            
            // Update progress bars
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const energyPercent = (gameState.player.energy / gameState.player.maxEnergy) * 100;
            const expPercent = (gameState.player.experience / gameState.player.experienceToNext) * 100;
            
            document.getElementById('barHealth').style.width = `${healthPercent}%`;
            document.getElementById('barEnergy').style.width = `${energyPercent}%`;
            document.getElementById('barExp').style.width = `${expPercent}%`;
            
            // Character tab
            document.getElementById('charName').textContent = gameState.player.name;
            document.getElementById('charAttack').textContent = gameState.player.attack;
            document.getElementById('charDefense').textContent = gameState.player.defense;
            document.getElementById('charCrit').textContent = gameState.player.critChance;
            document.getElementById('charDodge').textContent = gameState.player.dodgeChance;
            document.getElementById('charPower').textContent = gameState.player.power;
            
            // Rank display
            const rankElement = document.getElementById('playerRankDisplay');
            if (rankElement) {
                rankElement.textContent = gameState.player.rank;
                const rankData = STATIC_DATA.RANKS.find(r => r.name === gameState.player.rank);
                if (rankData) {
                    rankElement.className = rankData.color;
                }
            }
        }

        function updateInventoryDisplay() {
            const inventoryGrid = document.getElementById('uiInventoryGrid');
            if (!inventoryGrid) return;
            
            inventoryGrid.innerHTML = '';
            
            for (let i = 0; i < CONFIG.MAX_INVENTORY; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.index = i;
                
                const item = gameState.inventory[i];
                if (item) {
                    slot.textContent = item.icon || 'üì¶';
                    slot.title = item.name;
                    
                    slot.addEventListener('click', () => {
                        if (item.type && ['weapon', 'armor', 'accessory'].includes(item.type)) {
                            equipItem(item, i);
                        }
                    });
                }
                
                inventoryGrid.appendChild(slot);
            }
            
            // Update inventory usage
            const usedSlots = gameState.inventory.filter(slot => slot !== null).length;
            const usageElement = document.getElementById('inventoryUsage');
            if (usageElement) {
                usageElement.textContent = `${usedSlots}/${CONFIG.MAX_INVENTORY}`;
            }
        }

        function updateEquipmentDisplay() {
            ['weapon', 'armor', 'accessory'].forEach(type => {
                const element = document.getElementById(`equip${type.charAt(0).toUpperCase() + type.slice(1)}`);
                if (element) {
                    const item = gameState.equipment[type];
                    if (item) {
                        element.textContent = item.icon || 'üì¶';
                        element.title = item.name;
                    } else {
                        element.textContent = '';
                        element.title = 'Empty';
                    }
                }
            });
        }

        function updateBuildingsDisplay() {
            const buildingsList = document.getElementById('uiBuildingsList');
            if (!buildingsList) return;
            
            buildingsList.innerHTML = '';
            
            Object.entries(STATIC_DATA.BUILDINGS).forEach(([buildingType, building]) => {
                const currentLevel = gameState.buildings[buildingType];
                
                const buildingCard = document.createElement('div');
                buildingCard.className = 'bg-stone-800 p-3 rounded';
                
                const cost = {};
                Object.entries(building.baseCost).forEach(([resource, amount]) => {
                    cost[resource] = Math.floor(amount * Math.pow(building.costFactor, currentLevel));
                });
                
                const costText = Object.entries(cost).map(([resource, amount]) => 
                    `${amount} ${resource}`
                ).join(', ');
                
                const canAffordBuilding = canAfford(cost);
                const isMaxLevel = currentLevel >= building.maxLevel;
                
                buildingCard.innerHTML = `
                    <h4 class="font-semibold mb-1">${building.icon} ${building.name}</h4>
                    <p class="text-xs text-stone-400 mb-2">Level ${currentLevel}/${building.maxLevel}</p>
                    <button 
                        class="w-full text-xs py-1 rounded ${isMaxLevel ? 'bg-stone-600 cursor-not-allowed' : 
                        canAffordBuilding ? 'bg-amber-600 hover:bg-amber-700' : 'bg-red-600 cursor-not-allowed'}"
                        ${isMaxLevel || !canAffordBuilding ? 'disabled' : ''}
                        onclick="buyBuilding('${buildingType}')"
                    >
                        ${isMaxLevel ? 'Max Level' : `Upgrade (${costText})`}
                    </button>
                `;
                
                buildingsList.appendChild(buildingCard);
            });
        }

        function updateAbilityDisplay() {
            for (let i = 0; i < 3; i++) {
                const slot = document.querySelector(`.ability-slot[data-slot="${i}"]`);
                if (!slot) continue;
                
                const abilityId = gameState.player.selectedAbilities[i];
                const ability = abilityId ? STATIC_DATA.ABILITIES[abilityId] : null;
                
                const icon = slot.querySelector('.ability-icon');
                const cooldownText = slot.querySelector('.ability-cooldown-text');
                
                if (ability) {
                    icon.textContent = ability.icon;
                    slot.title = ability.name;
                    
                    const cooldownEnd = gameState.abilityCooldowns[abilityId];
                    if (cooldownEnd && cooldownEnd > Date.now()) {
                        const remaining = Math.ceil((cooldownEnd - Date.now()) / 1000);
                        cooldownText.textContent = remaining + 's';
                        slot.classList.add('cooldown');
                    } else {
                        cooldownText.textContent = '';
                        slot.classList.remove('cooldown');
                    }
                    
                    slot.onclick = () => useAbility(abilityId);
                } else {
                    icon.textContent = '‚ùî';
                    cooldownText.textContent = '';
                    slot.title = 'No ability assigned';
                    slot.onclick = null;
                }
            }
        }

        function updateGameLog() {
            const logElement = document.getElementById('uiGameLog');
            if (!logElement) return;
            
            logElement.innerHTML = gameState.gameLog.slice(0, 20).join('<br>');
            logElement.scrollTop = logElement.scrollHeight;
        }

        function updateChatDisplay() {
            const chatElement = document.getElementById('uiChatMessages');
            if (!chatElement) return;
            
            const messages = gameState.chat.messages.slice(-20).map(msg => {
                const time = new Date(msg.timestamp).toLocaleTimeString();
                return `<div class="text-xs"><span class="text-stone-500">[${time}]</span> <span class="text-amber-400">${msg.playerName}:</span> ${msg.text}</div>`;
            }).join('');
            
            chatElement.innerHTML = messages;
            chatElement.scrollTop = chatElement.scrollHeight;
        }

        function updateUI() {
            updateResourceDisplay();
            updatePlayerStats();
            updateInventoryDisplay();
            updateEquipmentDisplay();
            updateBuildingsDisplay();
            updateAbilityDisplay();
            updateGameLog();
            updateChatDisplay();
        }

        // === GAME INITIALIZATION ===
        function initializeGame() {
            // Set player ID
            gameState.player.id = generateId();
            
            // Initialize map
            initializeMap();
            
            // Add some starting items
            addToInventory(STATIC_DATA.ITEMS.rustyBlade);
            addToInventory(STATIC_DATA.ITEMS.stillsuit);
            
            // Add starting abilities
            gameState.player.abilities = ['sandstorm', 'crysknife'];
            gameState.player.selectedAbilities = ['sandstorm', 'crysknife', null];
            
            // Mark as initialized
            gameState.gameInitialized = true;
            gameState.isLoading = false;
            
            // Hide loading screen
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
            
            // Initial UI update
            updateUI();
            renderMap();
            
            // Start game loop
            startGameLoop();
            
            logEvent('Welcome to Arrakis! The spice must flow...');
            showNotification('Welcome to Arrakis!', 'success');
        }

        // === GAME LOOP ===
        function startGameLoop() {
            setInterval(() => {
                // Energy regeneration
                if (Date.now() - gameState.lastEnergyRegen >= CONFIG.ENERGY_REGEN_INTERVAL) {
                    gameState.player.energy = Math.min(gameState.player.maxEnergy, gameState.player.energy + CONFIG.ENERGY_REGEN_RATE);
                    gameState.lastEnergyRegen = Date.now();
                }
                
                // Update ability cooldowns display
                updateAbilityDisplay();
                
                // Update player stats display
                updatePlayerStats();
                
                // Auto-save (simplified)
                if (Date.now() - gameState.lastSaveTime >= CONFIG.SAVE_INTERVAL) {
                    gameState.lastSaveTime = Date.now();
                    // In a real game, this would save to Firebase
                }
                
            }, 1000);
        }

        // === EVENT LISTENERS ===
        document.addEventListener('DOMContentLoaded', () => {
            // Tab switching
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Update active tab button
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    // Show corresponding tab content
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
                    const tabId = button.dataset.tab + 'Tab';
                    const activeTab = document.getElementById(tabId);
                    if (activeTab) {
                        activeTab.classList.remove('hidden');
                        gameState.currentTab = button.dataset.tab;
                        
                        // Special handling for certain tabs
                        if (button.dataset.tab === 'game') {
                            renderMap();
                        }
                    }
                });
            });
            
            // Combat action buttons
            document.getElementById('combatActionAttack')?.addEventListener('click', () => combatAction('attack'));
            document.getElementById('combatActionDefend')?.addEventListener('click', () => combatAction('defend'));
            document.getElementById('combatActionFlee')?.addEventListener('click', () => combatAction('flee'));
            
            // Chat system
            document.getElementById('uiChatSend')?.addEventListener('click', sendChatMessage);
            document.getElementById('uiChatInput')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendChatMessage();
            });
            
            // Harvest buttons (add to UI dynamically or as needed)
            const harvestButtons = [
                { id: 'harvestSpice', type: 'spice', text: 'Harvest Spice' },
                { id: 'harvestWater', type: 'water', text: 'Extract Water' },
                { id: 'harvestPlasteel', type: 'plasteel', text: 'Mine Plasteel' }
            ];
            
            // Movement keys
            document.addEventListener('keydown', (e) => {
                if (gameState.combat.active) return;
                
                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        movePlayer(0, -1);
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        movePlayer(0, 1);
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        movePlayer(-1, 0);
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        movePlayer(1, 0);
                        break;
                    case ' ':
                        e.preventDefault();
                        harvestResource('spice');
                        break;
                }
            });
            
            // Initialize the game
            initializeGame();
        });

        // === GLOBAL FUNCTIONS (for onclick handlers) ===
        window.buyBuilding = buyBuilding;
        window.harvestResource = harvestResource;
        window.combatAction = combatAction;
        window.movePlayer = movePlayer;
        window.useAbility = useAbility;

    </script>

    <div id="loadingScreen" class="fixed inset-0 bg-stone-950 text-white flex items-center justify-center z-[10000]">
        <div class="text-center">
            <div class="text-4xl font-orbitron text-amber-400 mb-4">üèúÔ∏è ARRAKIS</div>
            <div class="text-xl">Loading the desert world...</div>
            <div class="mt-4 text-amber-300">The spice must flow...</div>
        </div>
    </div>

    <header class="bg-stone-800 border-b border-stone-700 px-4 py-3 fixed top-0 left-0 right-0 z-100">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-4">
                <h1 class="text-2xl font-orbitron font-bold text-amber-400">Arrakis Tycoon MMO</h1>
                <span class="text-xs text-amber-200 italic">The Spice Must Flow...</span>
            </div>
            <div class="flex items-center space-x-4">
                <div class="text-sm">
                    <span class="text-stone-400">Rank:</span>
                    <span id="playerRankDisplay" class="font-semibold text-stone-400">Novice</span>
                </div>
                <div class="text-sm">
                    <span class="text-stone-400">Power:</span>
                    <span id="playerPowerDisplay" class="font-semibold text-purple-400">0</span>
                </div>
            </div>
        </div>
    </header>

    <nav class="bg-stone-800 border-b border-stone-700 px-4 fixed top-[60px] left-0 right-0 z-100">
        <div class="flex space-x-1">
            <button class="tab-button active px-3 py-2 text-sm font-medium border-b-2 border-transparent hover:text-amber-400" data-tab="game">üèúÔ∏è Map</button>
            <button class="tab-button px-3 py-2 text-sm font-medium border-b-2 border-transparent hover:text-amber-400" data-tab="character">üë§ Character</button>
            <button class="tab-button px-3 py-2 text-sm font-medium border-b-2 border-transparent hover:text-amber-400" data-tab="base">üèóÔ∏è Base</button>
            <button class="tab-button px-3 py-2 text-sm font-medium border-b-2 border-transparent hover:text-amber-400" data-tab="multiplayer">üèÜ Rankings</button>
        </div>
    </nav>

    <main class="flex pt-[108px] h-screen">
        <!-- Left Sidebar -->
        <aside class="w-64 bg-stone-800 border-r border-stone-700 flex flex-col p-3 space-y-4 overflow-y-auto">
            <div>
                <h3 class="text-base font-semibold text-amber-400 mb-2">üì¶ Resources</h3>
                <div class="space-y-1 text-sm">
                    <div class="flex items-center justify-between">
                        <span>‚ú® Spice:</span>
                        <span id="resourceSpice" class="font-mono text-amber-300">0</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>üíß Water:</span>
                        <span id="resourceWater" class="font-mono text-blue-300">100</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>üí∞ Solari:</span>
                        <span id="resourceSolari" class="font-mono text-yellow-300">500</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>üîß Plasteel:</span>
                        <span id="resourcePlasteel" class="font-mono text-gray-300">50</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>üíé Rare Mat:</span>
                        <span id="resourceRareMaterials" class="font-mono text-purple-300">0</span>
                    </div>
                </div>
            </div>
            
            <div>
                <h3 class="text-base font-semibold text-amber-400 mb-2">‚ö° Player Stats</h3>
                <div class="space-y-1 text-xs">
                    <div>Health: <span id="statHealth">100/100</span>
                        <div class="progress-bar-bg rounded h-1.5 mt-0.5">
                            <div id="barHealth" class="progress-bar-fill h-full rounded" style="width: 100%"></div>
                        </div>
                    </div>
                    <div>Energy: <span id="statEnergy">100/100</span>
                        <div class="progress-bar-bg rounded h-1.5 mt-0.5">
                            <div id="barEnergy" class="bg-blue-500 h-full rounded" style="width: 100%"></div>
                        </div>
                    </div>
                    <div>Level: <span id="statLevel">1</span> (<span id="statExp">0/100</span>)
                        <div class="progress-bar-bg rounded h-1.5 mt-0.5">
                            <div id="barExp" class="bg-purple-500 h-full rounded" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div>
                <h3 class="text-base font-semibold text-amber-400 mb-2">üåü Abilities</h3>
                <div id="uiAbilitySlots" class="flex gap-2 justify-around">
                    <div class="ability-slot" data-slot="0">
                        <span class="ability-icon">‚ùî</span>
                        <span class="ability-cooldown-text"></span>
                    </div>
                    <div class="ability-slot" data-slot="1">
                        <span class="ability-icon">‚ùî</span>
                        <span class="ability-cooldown-text"></span>
                    </div>
                    <div class="ability-slot" data-slot="2">
                        <span class="ability-icon">‚ùî</span>
                        <span class="ability-cooldown-text"></span>
                    </div>
                </div>
            </div>
            
            <div>
                <h3 class="text-base font-semibold text-amber-400 mb-2">‚ö° Quick Actions</h3>
                <div class="space-y-1">
                    <button onclick="harvestResource('spice')" class="w-full text-xs py-1 bg-amber-600 hover:bg-amber-700 rounded">
                        ‚ú® Harvest Spice (5 energy)
                    </button>
                    <button onclick="harvestResource('water')" class="w-full text-xs py-1 bg-blue-600 hover:bg-blue-700 rounded">
                        üíß Extract Water (8 energy)
                    </button>
                </div>
            </div>
            
            <div class="flex-1">
                <h3 class="text-base font-semibold text-amber-400 mb-2">üìú Event Log</h3>
                <div id="uiGameLog" class="h-48 bg-stone-900 rounded p-2 text-xs overflow-y-auto"></div>
            </div>
        </aside>

        <!-- Main Content -->
        <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Game Tab -->
            <div id="gameTab" class="tab-content flex-1 p-4 overflow-y-auto">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-xl font-orbitron text-amber-400">üèúÔ∏è Arrakis Desert</h2>
                    <div class="text-sm text-stone-400">
                        Position: <span id="mapPlayerCoords" class="text-amber-300">50,50</span>
                    </div>
                </div>
                
                <div class="mb-4 text-center">
                    <div class="text-xs text-stone-400 mb-2">Use WASD or arrow keys to move ‚Ä¢ Space to harvest ‚Ä¢ Click cells to interact</div>
                    <div id="uiMapGrid" class="map-grid"></div>
                </div>
            </div>
            
            <!-- Character Tab -->
            <div id="characterTab" class="tab-content hidden flex-1 p-4 overflow-y-auto">
                <h2 class="text-xl font-orbitron text-amber-400 mb-3">üë§ Character & Inventory</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div class="bg-stone-800 p-3 rounded">
                        <h3 class="text-lg font-semibold mb-2">Character Stats</h3>
                        <div class="space-y-1 text-sm">
                            <p>Name: <span id="charName" class="text-amber-300">Survivor</span></p>
                            <p>Level: <span id="charLevel" class="text-green-400">1</span></p>
                            <p>Attack: <span id="charAttack" class="text-red-400">10</span></p>
                            <p>Defense: <span id="charDefense" class="text-blue-400">5</span></p>
                            <p>Crit Chance: <span id="charCrit" class="text-yellow-400">5</span>%</p>
                            <p>Dodge Chance: <span id="charDodge" class="text-green-400">10</span>%</p>
                            <p>Power Rating: <span id="charPower" class="text-purple-400">0</span></p>
                        </div>
                    </div>
                    
                    <div class="bg-stone-800 p-3 rounded">
                        <h3 class="text-lg font-semibold mb-2">Equipment</h3>
                        <div class="grid grid-cols-3 gap-2 text-center">
                            <div>
                                <div id="equipWeapon" class="inventory-slot mx-auto"></div>
                                <span class="text-xs">Weapon</span>
                            </div>
                            <div>
                                <div id="equipArmor" class="inventory-slot mx-auto"></div>
                                <span class="text-xs">Armor</span>
                            </div>
                            <div>
                                <div id="equipAccessory" class="inventory-slot mx-auto"></div>
                                <span class="text-xs">Accessory</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-stone-800 p-3 rounded">
                    <h3 class="text-lg font-semibold mb-2">Inventory (<span id="inventoryUsage">0/24</span>)</h3>
                    <div id="uiInventoryGrid" class="grid grid-cols-6 sm:grid-cols-8 gap-2"></div>
                </div>
            </div>
            
            <!-- Base Tab -->
            <div id="baseTab" class="tab-content hidden flex-1 p-4 overflow-y-auto">
                <h2 class="text-xl font-orbitron text-amber-400 mb-3">üèóÔ∏è Base Management</h2>
                
                <div id="uiBuildingsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            </div>
            
            <!-- Multiplayer Tab -->
            <div id="multiplayerTab" class="tab-content hidden flex-1 p-4 overflow-y-auto">
                <h2 class="text-xl font-orbitron text-amber-400 mb-3">üèÜ Rankings & PvP</h2>
                
                <div class="bg-stone-800 p-3 rounded">
                    <h3 class="text-lg font-semibold mb-2">Top Players</h3>
                    <div class="text-sm text-stone-400">
                        Rankings will be updated when multiplayer features are connected to Firebase.
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <aside class="w-72 bg-stone-800 border-l border-stone-700 flex flex-col p-3 space-y-3 overflow-y-auto">
            <div>
                <h3 class="text-base font-semibold text-amber-400 mb-2">üó∫Ô∏è Minimap</h3>
                <div class="minimap mx-auto"></div>
            </div>
            
            <div>
                <h3 class="text-base font-semibold text-amber-400 mb-2">üë• Nearby Players</h3>
                <div id="uiPlayerList" class="space-y-1 text-xs max-h-32 overflow-y-auto">
                    <div class="text-stone-400">No other players nearby</div>
                </div>
            </div>
            
            <div class="flex-1 flex flex-col">
                <h3 class="text-base font-semibold text-amber-400 mb-2">üí¨ Global Chat</h3>
                <div id="uiChatMessages" class="flex-1 bg-stone-900 rounded p-2 text-xs overflow-y-auto mb-2 min-h-[200px]"></div>
                <div class="flex">
                    <input id="uiChatInput" type="text" placeholder="Type message..." 
                           class="flex-1 px-2 py-1 bg-stone-700 rounded-l text-xs border border-stone-600 focus:border-amber-500 outline-none" 
                           maxlength="100">
                    <button id="uiChatSend" class="px-3 py-1 bg-amber-600 hover:bg-amber-700 rounded-r text-xs">Send</button>
                </div>
            </div>
        </aside>
    </main>

    <!-- Combat Modal -->
    <div id="modalCombat" class="modal-overlay hidden">
        <div class="modal-content w-full max-w-lg">
            <h3 class="text-xl font-orbitron text-red-500 mb-3 text-center">‚öîÔ∏è COMBAT ‚öîÔ∏è</h3>
            
            <div class="grid grid-cols-2 gap-4 mb-3">
                <div>
                    <div class="flex justify-between items-baseline">
                        <span id="modalCombatPlayerName" class="font-semibold">Player</span>
                        <span id="modalCombatPlayerLevel" class="text-xs text-stone-400">Lv.1</span>
                    </div>
                    <div class="text-xs mb-1">HP: <span id="modalCombatPlayerHealth">100/100</span></div>
                    <div class="progress-bar-bg rounded h-2.5">
                        <div id="modalCombatPlayerHealthBar" class="progress-bar-fill h-full rounded" style="width: 100%"></div>
                    </div>
                    <div class="text-xs mt-1">Energy: <span id="modalCombatPlayerEnergy">100/100</span></div>
                    <div class="progress-bar-bg rounded h-2.5">
                        <div id="modalCombatPlayerEnergyBar" class="bg-blue-500 h-full rounded" style="width: 100%"></div>
                    </div>
                </div>
                
                <div>
                    <div class="flex justify-between items-baseline">
                        <span id="modalCombatEnemyName" class="font-semibold">Enemy</span>
                        <span id="modalCombatEnemyLevel" class="text-xs text-stone-400">Lv.1</span>
                    </div>
                    <div class="text-xs mb-1">HP: <span id="modalCombatEnemyHealth">50/50</span></div>
                    <div class="progress-bar-bg rounded h-2.5">
                        <div id="modalCombatEnemyHealthBar" class="bg-red-600 h-full rounded" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <div id="modalCombatLog" class="bg-stone-900 rounded p-2 h-32 overflow-y-auto text-xs mb-3 border border-stone-700"></div>
            
            <div class="grid grid-cols-3 gap-2 mb-2">
                <button id="combatActionAttack" class="py-2 bg-red-600 hover:bg-red-700 rounded text-sm">‚öîÔ∏è Attack</button>
                <button id="combatActionDefend" class="py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm">üõ°Ô∏è Defend</button>
                <button id="combatActionFlee" class="py-2 bg-stone-600 hover:bg-stone-700 rounded text-sm">üí® Flee</button>
            </div>
            
            <div id="modalCombatTurnIndicator" class="text-center text-xs text-amber-400">Your Turn</div>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notificationContainer" class="fixed top-16 right-4 space-y-2 z-[9999]"></div>

</body>
</html>
